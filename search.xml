<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>买卖股票问题总结</title>
    <url>/2022/11/25/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="买卖股票问题综合"><a href="#买卖股票问题综合" class="headerlink" title="买卖股票问题综合"></a>买卖股票问题综合</h2><h3 id="lc-121-买卖股票的最佳时机i（买卖一次）"><a href="#lc-121-买卖股票的最佳时机i（买卖一次）" class="headerlink" title="lc 121 买卖股票的最佳时机i（买卖一次）"></a>lc 121 买卖股票的最佳时机i（买卖一次）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-keyword">if</span> (prices == <span class="hljs-literal">null</span> || prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++ ) &#123;<br>        min = Math.min(min, prices[i]);<br>        res = Math.max(res, prices[i] - min);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>    <span class="hljs-keyword">if</span> (prices == <span class="hljs-literal">null</span> || prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++ ) &#123;<br>        f[i][<span class="hljs-number">1</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]); <span class="hljs-comment">// 只能买一次</span><br>        f[i][<span class="hljs-number">0</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], prices[i] + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="lc-122-买卖股票的最佳时机ii（买卖多次）"><a href="#lc-122-买卖股票的最佳时机ii（买卖多次）" class="headerlink" title="lc 122 买卖股票的最佳时机ii（买卖多次）"></a>lc 122 买卖股票的最佳时机ii（买卖多次）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-comment">// // 有利润就加</span><br>    <span class="hljs-comment">// if (prices == null || prices.length == 0) return 0;</span><br>    <span class="hljs-comment">// int res = 0;</span><br>    <span class="hljs-comment">// for (int i = 1; i &lt; prices.length; i++ ) &#123;</span><br>    <span class="hljs-comment">//     res += Math.max(0, prices[i] - prices[i - 1]);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// return res;</span><br><br>    <span class="hljs-keyword">if</span> (prices == <span class="hljs-literal">null</span> || prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++ ) &#123;<br>        f[i][<span class="hljs-number">0</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>        f[i][<span class="hljs-number">1</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]); <span class="hljs-comment">// 可以买多次 </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> f[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="lc-123-买卖股票的最佳时机iii-买卖两次"><a href="#lc-123-买卖股票的最佳时机iii-买卖两次" class="headerlink" title="lc 123 买卖股票的最佳时机iii (买卖两次)"></a>lc 123 买卖股票的最佳时机iii (买卖两次)</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// f[i][j] 表示第i天处于状态j的最大利润，不是说第i天一定买卖</span><br>		<span class="hljs-comment">// 0-不操作，1-第一次买入，2-第一次卖出，3-第二次买入，4-第二次卖出</span><br>        <span class="hljs-keyword">if</span> (prices == <span class="hljs-literal">null</span> || prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">5</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++ ) &#123;<br>            f[i][<span class="hljs-number">0</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            f[i][<span class="hljs-number">1</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            f[i][<span class="hljs-number">2</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            f[i][<span class="hljs-number">3</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>            f[i][<span class="hljs-number">4</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="lc-188-买卖股票的最佳时机-iv-（买卖k次）"><a href="#lc-188-买卖股票的最佳时机-iv-（买卖k次）" class="headerlink" title="lc 188 买卖股票的最佳时机 iv （买卖k次）"></a>lc 188 买卖股票的最佳时机 iv （买卖k次）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-keyword">if</span> (prices == <span class="hljs-literal">null</span> || prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span> ) &#123;<br>        f[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++ ) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<br>            f[i][j] = Math.max(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - prices[i]);<br>            f[i][j + <span class="hljs-number">1</span>] = Math.max(f[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j] + prices[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> f[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">2</span> * k];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="lc-309-买卖股票的最佳时机（含冷冻期）"><a href="#lc-309-买卖股票的最佳时机（含冷冻期）" class="headerlink" title="lc 309 买卖股票的最佳时机（含冷冻期）"></a>lc 309 买卖股票的最佳时机（含冷冻期）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// 0-持有 1-卖出并过冷冻期，2-今天卖，3-今天冷冻</span><br><br>        <span class="hljs-keyword">if</span> (prices == <span class="hljs-literal">null</span> || prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">4</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++ ) &#123;<br>            f[i][<span class="hljs-number">0</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]) - prices[i]);<br>            f[i][<span class="hljs-number">1</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            f[i][<span class="hljs-number">2</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>            f[i][<span class="hljs-number">3</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-keyword">return</span> Math.max(Math.max(f[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]), f[n - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="lc-714-买卖股票的最佳时机（含手续费）"><a href="#lc-714-买卖股票的最佳时机（含手续费）" class="headerlink" title="lc 714 买卖股票的最佳时机（含手续费）"></a>lc 714 买卖股票的最佳时机（含手续费）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> fee)</span> &#123;<br>        <span class="hljs-keyword">if</span> (prices == <span class="hljs-literal">null</span> || prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++ ) &#123;<br>            f[i][<span class="hljs-number">0</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i] - fee);<br>            f[i][<span class="hljs-number">1</span>] = Math.max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(f[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题相关</category>
      </categories>
      <tags>
        <tag>买卖股票问题综合</tag>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树类型</title>
    <url>/2022/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="二叉树的总结"><a href="#二叉树的总结" class="headerlink" title="二叉树的总结"></a>二叉树的总结</h3><h4 id="1、满二叉树"><a href="#1、满二叉树" class="headerlink" title="1、满二叉树"></a>1、满二叉树</h4><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p>
<p><img src="/2022/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E5%9E%8B/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p>
<h4 id="2、完全二叉树"><a href="#2、完全二叉树" class="headerlink" title="2、完全二叉树"></a>2、完全二叉树</h4><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1  个节点。<br><img src="/2022/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E5%9E%8B/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"><br><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系</strong></p>
<h4 id="3、二叉搜索树"><a href="#3、二叉搜索树" class="headerlink" title="3、二叉搜索树"></a>3、二叉搜索树</h4><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p><img src="/2022/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E5%9E%8B/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p>
<h4 id="4、平衡二叉搜索树"><a href="#4、平衡二叉搜索树" class="headerlink" title="4、平衡二叉搜索树"></a>4、平衡二叉搜索树</h4><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p><img src="/2022/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E5%9E%8B/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="平衡二叉搜索树"></p>
<h4 id="5、数据结构"><a href="#5、数据结构" class="headerlink" title="5、数据结构"></a>5、数据结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    Node left;<br>    Node right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
        <tag>满二叉树</tag>
        <tag>平衡二叉树</tag>
        <tag>二叉搜索树</tag>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Start</title>
    <url>/2022/11/24/Quick%20Start/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>git的使用</title>
    <url>/2022/11/25/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Git的安装与配置"><a href="#Git的安装与配置" class="headerlink" title="Git的安装与配置"></a>Git的安装与配置</h2><h3 id="（1）-Git的配置"><a href="#（1）-Git的配置" class="headerlink" title="（1） Git的配置"></a>（1） Git的配置</h3><p>在 ~&#x2F;.gitconfig中</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">git config --<span class="hljs-keyword">global</span> user.name 你的英文名 lam<br>git config --<span class="hljs-keyword">global</span> user.email 你的邮箱 <br>git config --<span class="hljs-keyword">global</span> push.<span class="hljs-literal">default</span> simple <span class="hljs-meta"># 配置git的默认，默认是Matching,此行为会push所有分支，simple只会push当前分支 </span><br>git config --<span class="hljs-keyword">global</span> core.quotepath <span class="hljs-literal">false</span> <span class="hljs-meta"># 防止文件名变成数字</span><br>git config --<span class="hljs-keyword">global</span> core.editor <span class="hljs-string">&quot;vim&quot;</span> <span class="hljs-meta"># 使用vim编辑提交信息</span><br></code></pre></td></tr></table></figure>



<h3 id="（2）-命令介绍"><a href="#（2）-命令介绍" class="headerlink" title="（2） 命令介绍"></a>（2） 命令介绍</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.git</span> init，初始化本地仓库 <span class="hljs-selector-class">.git</span><br><br><span class="hljs-number">2</span><span class="hljs-selector-class">.git</span> status -sb，显示当前所有文件的状态<br><br><span class="hljs-number">3</span><span class="hljs-selector-class">.git</span> log 查看变更历史<br><br><span class="hljs-number">4</span><span class="hljs-selector-class">.git</span> add 文件路径，用来将变动加到暂存区<br><br><span class="hljs-number">5</span><span class="hljs-selector-class">.git</span> commit -m <span class="hljs-string">&quot;信息&quot;</span>，用来正式提交变动，提交至 <span class="hljs-selector-class">.git</span> 仓库<br><br><span class="hljs-number">6</span>.如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m <span class="hljs-string">&#x27;xxx&#x27;</span> 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。<br><br><span class="hljs-number">7</span><span class="hljs-selector-class">.git</span> clone git@github<span class="hljs-selector-class">.com</span>:xxxx，下载仓库<br><br><span class="hljs-number">8</span><span class="hljs-selector-class">.history</span> 是显示历史的命令<br></code></pre></td></tr></table></figure>



<h3 id="（3）-使用git"><a href="#（3）-使用git" class="headerlink" title="（3） 使用git"></a>（3） 使用git</h3><p><strong>使用总结</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>、从github或者gitee下载代码<br>git clone git@github.com:msclam/blog.git<br><br><span class="hljs-number">2</span>、上传我们的代码到github或者gitee中<br>git <span class="hljs-keyword">add</span> .<br>git <span class="hljs-keyword">commit</span> . -m &quot;信息&quot;<br>git pull 从服务器中拉代码<br>git push 推送代码到github或者gitee中<br><br><span class="hljs-number">3</span>、合作发生冲突时<br>别人修改了代码，但是自己没有先pull,自己也修改了代码，然后pull的时候，会要求你先添加到暂存区+本地仓库<span class="hljs-keyword">add</span>和<span class="hljs-keyword">commit</span><br>然后如果pull产生<span class="hljs-keyword">conflict</span>的话，需要处理冲突,head的部分是自己的修改地方，解决冲突之后重新提交<br><br><span class="hljs-number">4</span>、个人新建仓库并往上面推代码<br>创建仓库<br>git init<br>git <span class="hljs-keyword">add</span> .<br>git <span class="hljs-keyword">commit</span> . -m &quot;&quot;<br>git remote <span class="hljs-keyword">add</span> origin git@github.com:msclam/blog.git  // 添加远程仓库<br>git push -u origin master// 如果没有推上去 git push <span class="hljs-comment">--set-upstream origin master</span><br><br>已经有就只需要后两句<br><br><span class="hljs-number">5</span>、添加一个新的远程仓库<br>git remote <span class="hljs-keyword">add</span> github https://github.com/msclam/blog.git<br>git remote -v // 查看自己有哪些远程仓库<br>git push github master<br><br><span class="hljs-number">6</span>、回退版本<br>git <span class="hljs-keyword">log</span>之后退出按q<br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^  //回退到上一个版本</span><br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD~n //回退到n次以前的版本</span><br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard commit号  //回退到指定的版本</span><br><br><span class="hljs-number">7</span>、分支<br>git checkout test // 切换分支<br>合并到master<br>git checkout master<br>git merge test<br>git push<br></code></pre></td></tr></table></figure>

<h4 id="日常工作的流程"><a href="#日常工作的流程" class="headerlink" title="日常工作的流程"></a>日常工作的流程</h4><p>上班先git pull然后git add commit，下班git pull，然后解决冲突，最后git push</p>
<p><img src="/2022/11/25/git%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%97%A5%E5%B8%B8%E6%B5%81%E7%A8%8B.png" alt="日常流程"></p>
<h4 id="关于推送不同的仓库"><a href="#关于推送不同的仓库" class="headerlink" title="关于推送不同的仓库"></a>关于推送不同的仓库</h4><p><img src="/2022/11/25/git%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%8E%A8%E9%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BB%93%E5%BA%93.png" alt="推送不同的仓库"></p>
<h4 id="关于冲突"><a href="#关于冲突" class="headerlink" title="关于冲突"></a>关于冲突</h4><p><img src="/2022/11/25/git%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%85%B3%E4%BA%8E%E5%86%B2%E7%AA%81.png" alt="关于冲突"></p>
<h4 id="关于分支"><a href="#关于分支" class="headerlink" title="关于分支"></a>关于分支</h4><p><img src="/2022/11/25/git%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%85%B3%E4%BA%8E%E5%88%86%E6%94%AF.png" alt="关于分支"></p>
]]></content>
      <categories>
        <category>工具相关</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git的配置与使用</tag>
        <tag>工具</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈问题总结</title>
    <url>/2022/11/25/%E5%8D%95%E8%B0%83%E6%A0%88%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="单调栈问题总结"><a href="#单调栈问题总结" class="headerlink" title="单调栈问题总结"></a>单调栈问题总结</h2><p>单调递增栈：</p>
<p>①在一个<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>中针对每一个元素从它右边寻找第一个比它小的元素</p>
<p>②在一个队列中针对每一个元素从它左边寻找第一个比它小的元素</p>
<p>单调递减栈：</p>
<p>①在一个队列中针对每一个元素从它右边寻找第一个比它大的元素</p>
<p>②在一个队列中针对每一个元素从它左边寻找第一个比它大的元素</p>
<span id="more"></span>

<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739 每日温度"></a>739 每日温度</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 <span class="hljs-number">0</span> 来代替。<br><br>例如，给定一个列表 temperatures = [<span class="hljs-number">73</span>, <span class="hljs-number">74</span>, <span class="hljs-number">75</span>, <span class="hljs-number">71</span>, <span class="hljs-number">69</span>, <span class="hljs-number">72</span>, <span class="hljs-number">76</span>, <span class="hljs-number">73</span>]，你的输出应该是 [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]。<br><br>提示：气温 列表长度的范围是 [<span class="hljs-number">1</span>, <span class="hljs-number">30000</span>]。每个气温的值的均为华氏度，都是在 [<span class="hljs-number">30</span>, <span class="hljs-number">100</span>] 范围内的整数。<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[temperatures.length];<br>    Stack&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; temperatures.length; i ++ ) &#123;<br>        <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[st.peek()]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIdx</span> <span class="hljs-operator">=</span> st.pop();<br>            res[preIdx] = i - preIdx;<br>        &#125;<br>        st.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;    <br></code></pre></td></tr></table></figure>

<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42 接雨水"></a>42 接雨水</h3><p><strong>重点：其实就是栈顶和栈顶的下一个元素以及要入栈的三个元素来接水！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]（就是图中的高度<span class="hljs-number">3</span>）。<br><br>此时大家应该可以发现**其实就是栈顶和栈顶的下一个元素以及要入栈的三个元素来接水！**<br><br>那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：<span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> min(height[st.top()], height[i]) - height[mid];<br><br>雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - <span class="hljs-number">1</span>（因为只求中间宽度），代码为：<span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> i - st.top() - <span class="hljs-number">1</span> ;<br><br>当前凹槽雨水的体积就是：h * w。<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-keyword">if</span> (height == <span class="hljs-literal">null</span> || height.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Stack&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i ++ ) &#123;<br>        <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; height[i] &gt; height[st.peek()]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> st.pop();<br>            <span class="hljs-keyword">if</span> (!st.isEmpty()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Math.min(height[i], height[st.peek()]) - height[mid];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> i - st.peek() - <span class="hljs-number">1</span>;<br>                sum += h * w;<br>            &#125;<br>        &#125;<br>        st.push(i);<br>    &#125;   <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84 柱状图中最大的矩形"></a>84 柱状图中最大的矩形</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <span class="hljs-number">1</span> 。<br><br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>    <span class="hljs-type">int</span>[] nHeights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[heights.length + <span class="hljs-number">2</span>];<br>    System.arraycopy(heights, <span class="hljs-number">0</span>, nHeights, <span class="hljs-number">1</span>, heights.length);<br><br>    Stack&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nHeights.length; i ++ ) &#123;<br>        <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; nHeights[i] &lt; nHeights[st.peek()]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> nHeights[st.pop()];<br>            area = Math.max(area, h * (i - st.peek() - <span class="hljs-number">1</span>));<br>        &#125;<br>        st.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> area;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="括号题目"><a href="#括号题目" class="headerlink" title="括号题目"></a>括号题目</h3>]]></content>
      <categories>
        <category>刷题相关</category>
      </categories>
      <tags>
        <tag>单调栈问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法模板</title>
    <url>/2022/11/25/%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h4 id="寻找左边第一个x"><a href="#寻找左边第一个x" class="headerlink" title="寻找左边第一个x"></a>寻找左边第一个x</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (arr[mid] &lt; x) l = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> r = mid;<br>&#125;<br><span class="hljs-keyword">if</span> (arr[l] != x) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> l;  <span class="hljs-comment">// l和r都是一样的，因为l = r跳出循环</span><br></code></pre></td></tr></table></figure>

<h4 id="寻找右边最后一个x"><a href="#寻找右边最后一个x" class="headerlink" title="寻找右边最后一个x"></a>寻找右边最后一个x</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 寻找最后一个x</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>; (注意改边界问题)<br>    <span class="hljs-keyword">if</span> (arr[mid] &gt; x) r = mid - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> l = mid;<br>&#125;<br><span class="hljs-keyword">if</span> (arr[l] != x) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> l;<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>回文串问题总结</title>
    <url>/2022/11/25/%E5%9B%9E%E6%96%87%E4%B8%B2%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="回文串总结"><a href="#回文串总结" class="headerlink" title="回文串总结"></a>回文串总结</h3><h4 id="1、最长回文串"><a href="#1、最长回文串" class="headerlink" title="1、最长回文串"></a>1、最长回文串</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">409.</span> 最长回文串 (构造最长的回文串长度)<br>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。<br>在构造过程中，请注意区分大小写。比如 <span class="hljs-string">&quot;Aa&quot;</span> 不能当做一个回文字符串。<br>    <br>输入:<br><span class="hljs-string">&quot;abccccdd&quot;</span><br>输出:<br><span class="hljs-number">7</span><br>解释:<br>我们可以构造的最长的回文串是<span class="hljs-string">&quot;dccaccd&quot;</span>, 它的长度是 <span class="hljs-number">7</span>。<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">char</span>[] str = s.toCharArray();<br>    <span class="hljs-type">int</span>[] mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length; i ++ ) &#123;<br>        mp[str[i]]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cnt : mp) &#123;<br>        res += cnt / <span class="hljs-number">2</span> * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; res % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            res++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2、最长回文子串"><a href="#2、最长回文子串" class="headerlink" title="2、最长回文子串"></a>2、最长回文子串</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">5.</span> 最长回文子串（回文子串）<br>给你一个字符串 s，找到 s 中最长的回文子串。<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String ss)</span> &#123;<br>    <span class="hljs-type">char</span>[] s = ss.toCharArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; mid &lt; n; mid ++ ) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mid;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j]) &#123;<br>            <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &gt; len) &#123;<br>                len = j - i + <span class="hljs-number">1</span>;<br>                x = i;<br>                y = j;<br>            &#125;<br>            i--;<br>            j++;<br>        &#125;<br>        i = mid - <span class="hljs-number">1</span>;<br>        j = mid;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j]) &#123;<br>            <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &gt; len) &#123;<br>                len = j - i + <span class="hljs-number">1</span>;<br>                x = i;<br>                y = j;<br>            &#125;<br>            i--;<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ss.substring(x, y + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">// 方式一</span><br>        <span class="hljs-comment">// char[] str = s.toCharArray();</span><br>        <span class="hljs-comment">// boolean[][] f = new boolean[str.length][str.length];</span><br>        <span class="hljs-comment">// for (boolean[] b : f) &#123;</span><br>        <span class="hljs-comment">//     Arrays.fill(b, false);</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-comment">// int len = 1;</span><br>        <span class="hljs-comment">// int x = 0;</span><br>        <span class="hljs-comment">// int y = 0;</span><br>        <span class="hljs-comment">// for (int j = 0; j &lt; str.length; j ++ ) &#123;</span><br>        <span class="hljs-comment">//     for (int i = 0; i &lt;= j; i ++ ) &#123;</span><br>        <span class="hljs-comment">//         if (str[i] == str[j] &amp;&amp; (j - i &lt;= 1 || f[i + 1][j - 1] == true)) &#123;</span><br>        <span class="hljs-comment">//             f[i][j] = true;</span><br>        <span class="hljs-comment">//             if (j - i + 1 &gt; len) &#123;</span><br>        <span class="hljs-comment">//                 len = j - i + 1;</span><br>        <span class="hljs-comment">//                 x = i;</span><br>        <span class="hljs-comment">//                 y = j;</span><br>        <span class="hljs-comment">//             &#125;</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return s.substring(x, y + 1);</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3、回文串数目"><a href="#3、回文串数目" class="headerlink" title="3、回文串数目"></a>3、回文串数目</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">647.</span> 回文子串（求回文串数目）<br>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。<br>回文字符串 是正着读和倒过来读一样的字符串。<br>子字符串 是字符串中的由连续字符组成的一个序列。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// 方式一</span><br>    <span class="hljs-comment">// int res = 0;</span><br>    <span class="hljs-comment">// char[] str = s.toCharArray();</span><br>    <span class="hljs-comment">// for (int mid = 0; mid &lt; str.length; mid ++ ) &#123;</span><br>    <span class="hljs-comment">//     int i = mid;</span><br>    <span class="hljs-comment">//     int j = mid;</span><br>    <span class="hljs-comment">//     while (i &gt;= 0 &amp;&amp; j &lt; str.length &amp;&amp; str[i] == str[j]) &#123;</span><br>    <span class="hljs-comment">//         i--;</span><br>    <span class="hljs-comment">//         j++;</span><br>    <span class="hljs-comment">//         res++;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     i = mid - 1;</span><br>    <span class="hljs-comment">//     j = mid;</span><br>    <span class="hljs-comment">//     while (i &gt;= 0 &amp;&amp; j &lt; str.length &amp;&amp; str[i] == str[j]) &#123;</span><br>    <span class="hljs-comment">//         i--;</span><br>    <span class="hljs-comment">//         j++;</span><br>    <span class="hljs-comment">//         res++;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// return res;</span><br><br>    <span class="hljs-comment">// 方式二</span><br>    <span class="hljs-type">char</span>[] str = s.toCharArray();<br>    <span class="hljs-type">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[str.length][str.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">boolean</span>[] b : f) &#123;<br>        Arrays.fill(b, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; str.length; j ++ ) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= j; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] == str[j] &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-literal">true</span>)) &#123;<br>                f[i][j] = <span class="hljs-literal">true</span>;<br>                res++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题相关</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>回文串总结</tag>
      </tags>
  </entry>
  <entry>
    <title>When You Are Old</title>
    <url>/2022/11/24/When%20you%20are%20old/</url>
    <content><![CDATA[<center>
    <h1>
        When you are old
    </h1>
</center>



<center>
    <strong>
        When you are old and grey and full of sleep,
        <br><br>
        And nodding by the fire,take down this book,
        <br><br>
        And slowly read,and dream of the soft look,
        <br><br>
        Your eyes had once,and of their shadows deep;
        <br><br>
        How many loved your moments of glad grace,
        <br><br>
        And loved your beauty with love false or true,
        <br><br>
        But one man loved the pilgrim soul in you,
        <br><br>
        And loved the sorrows of your changing face;
        <br><br>
        And bending down beside the glowing bars,
        <br><br>
        Murmur,a little sadly,how love fled,
        <br><br>
        And paced upon the mountains overhead,
        <br><br>
        And hid his face amid a crowd of stars.
    </strong>



<hr>
<p>​    </p>
</center>]]></content>
      <categories>
        <category>literature</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>English</tag>
        <tag>poetry</tag>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍问题总结</title>
    <url>/2022/11/25/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="打家劫舍问题总结"><a href="#打家劫舍问题总结" class="headerlink" title="打家劫舍问题总结"></a>打家劫舍问题总结</h2><h3 id="lc-198-打家劫舍"><a href="#lc-198-打家劫舍" class="headerlink" title="lc 198 打家劫舍"></a>lc 198 打家劫舍</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// f[i]表示前i个房子的最大价值</span><br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    f[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++ ) &#123;<br>        f[i] = Math.max(nums[i - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">2</span>], f[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="lc-213-打家劫舍ii-（成环）"><a href="#lc-213-打家劫舍ii-（成环）" class="headerlink" title="lc 213 打家劫舍ii  （成环）"></a>lc 213 打家劫舍ii  （成环）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-type">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>    f[<span class="hljs-number">0</span>] = g[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    f[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>    g[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n - <span class="hljs-number">1</span>; i++ ) &#123;<br>        f[i] = Math.max(f[i - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>]);<br>        g[i] = Math.max(g[i - <span class="hljs-number">1</span>], g[i - <span class="hljs-number">2</span>] + nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.max(f[n - <span class="hljs-number">1</span>], g[n - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="lc-337-打家劫舍iii-（树形）"><a href="#lc-337-打家劫舍iii-（树形）" class="headerlink" title="lc 337 打家劫舍iii  （树形）"></a>lc 337 打家劫舍iii  （树形）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-type">int</span>[] res = dfs(root);<br>    <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dfs(TreeNode root) &#123;<br>    <span class="hljs-comment">// res[0]当前节点不偷的最大价值, res[1]当前节点偷的最大价值</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>]; <br><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br><br>    <span class="hljs-type">int</span>[] left = dfs(root.left);<br>    <span class="hljs-type">int</span>[] right = dfs(root.right);<br><br>    res[<span class="hljs-number">1</span>] = root.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>    res[<span class="hljs-number">0</span>] = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题相关</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>打家劫舍问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/11/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p><strong>选择型：简单选择、堆排序</strong></p>
<p><strong>插入型：直接插入、折半插入、希尔排序</strong></p>
<p><strong>交换型：快速排序、冒泡排序</strong></p>
<p><strong>分治型：归并排序</strong></p>
</blockquote>
<p><img src="/2022/11/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.png" alt="sort"></p>
<h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><h3 id="（一）快速排序"><a href="#（一）快速排序" class="headerlink" title="（一）快速排序"></a>（一）快速排序</h3><blockquote>
<p>版本一</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l, j = r, x = A[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span> (A[i] &lt; x) i ++;<br>        <span class="hljs-keyword">while</span> (A[j] &gt; x) j --;<br>        <span class="hljs-keyword">if</span> (i &lt;= j) &#123;<br>            <span class="hljs-built_in">swap</span>(A[i], A[j]);<br>            i ++;<br>            j --;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &lt; j) <span class="hljs-built_in">quickSort</span>(A, l, j);<br>    <span class="hljs-keyword">if</span> (i &lt; r) <span class="hljs-built_in">quickSort</span>(A, i, r);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>版本二</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = A[l];<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; A[r] &gt; x) r --;<br>        A[l] = A[r];<br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; A[l] &lt;= x) l ++;<br>        A[r] = A[l]; <br>    &#125;<br>    A[l] = x;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> pos = <span class="hljs-built_in">partition</span>(A, l, r);<br>        <span class="hljs-built_in">quick_sort</span>(A, l, pos - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quick_sort</span>(A, pos + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（二）归并排序"><a href="#（二）归并排序" class="headerlink" title="（二）归并排序"></a>（二）归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> l1, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> l2, <span class="hljs-type">int</span> r2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = r2 - l1 + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> i = l1, j = l2, idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;<br>        <span class="hljs-keyword">if</span> (A[i] &lt;= A[j]) &#123;<br>            tmp[idx++] = A[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmp[idx++] = A[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= r1) tmp[idx++] = A[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r2) tmp[idx++] = A[j++];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i ++ ) &#123;<br>        A[l1 + i] = tmp[i];<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">mergeSort</span>(A, l, mid);<br>        <span class="hljs-built_in">mergeSort</span>(A, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">merge</span>(A, l, mid, mid + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（三）堆排序"><a href="#（三）堆排序" class="headerlink" title="（三）堆排序"></a>（三）堆排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adjustDown</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = low, j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= high &amp;&amp; A[j + <span class="hljs-number">1</span>] &gt; A[j]) &#123;<br>            j ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (A[j] &gt; A[i]) &#123;<br>            <span class="hljs-built_in">swap</span>(A[j], A[i]);<br>            i = j;<br>            j = <span class="hljs-number">2</span> * j + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) &#123;<br>        <span class="hljs-built_in">adjustDown</span>(A, i, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i -- ) &#123;<br>        <span class="hljs-built_in">swap</span>(A[<span class="hljs-number">0</span>], A[i]);<br>        <span class="hljs-built_in">adjustDown</span>(A, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（四）冒泡排序"><a href="#（四）冒泡排序" class="headerlink" title="（四）冒泡排序"></a>（四）冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ ) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (A[j] &gt; A[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(A[j], A[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（五）选择排序"><a href="#（五）选择排序" class="headerlink" title="（五）选择排序"></a>（五）选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ ) &#123;<br>        <span class="hljs-type">int</span> min = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (A[j] &lt; A[min]) &#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min != i) &#123;<br>            <span class="hljs-built_in">swap</span>(A[min], A[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（六）直接插入"><a href="#（六）直接插入" class="headerlink" title="（六）直接插入"></a>（六）直接插入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>        <span class="hljs-type">int</span> tmp = A[i], j;<br>        <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp &lt; A[j]; j -- ) &#123;<br>            A[j + <span class="hljs-number">1</span>] = A[j];<br>        &#125;<br>        A[j + <span class="hljs-number">1</span>] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（七）折半插入"><a href="#（七）折半插入" class="headerlink" title="（七）折半插入"></a>（七）折半插入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">halfInsertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>        <span class="hljs-type">int</span> tmp = A[i], j;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = i;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (A[mid] &lt;= tmp) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= l; j -- ) &#123;<br>            A[j + <span class="hljs-number">1</span>] = A[j];<br>        &#125;<br>        A[j + <span class="hljs-number">1</span>] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（八）希尔排序"><a href="#（八）希尔排序" class="headerlink" title="（八）希尔排序"></a>（八）希尔排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dk = n / <span class="hljs-number">2</span>; dk &gt;= <span class="hljs-number">1</span>; dk /= <span class="hljs-number">2</span> ) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = dk; i &lt; n; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (A[i - dk] &gt; A[i]) &#123;<br>                <span class="hljs-type">int</span> tmp = A[i], j;<br>                <span class="hljs-keyword">for</span> (j = i - dk; j &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp &lt; A[j]; j -= dk ) &#123;<br>                    A[j + dk] = A[j];<br>                &#125;<br>                A[j + dk] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><h3 id="（一）冒泡排序"><a href="#（一）冒泡排序" class="headerlink" title="（一）冒泡排序"></a>（一）冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br> 	<span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span> &amp;&amp; flag; i ++ ) &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                swap(arr, j, j + <span class="hljs-number">1</span>);<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="（二）选择排序"><a href="#（二）选择排序" class="headerlink" title="（二）选择排序"></a>（二）选择排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ ) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">// 攻擂台</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) &#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        swap(arr, i, min);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="（三）快速排序"><a href="#（三）快速排序" class="headerlink" title="（三）快速排序"></a>（三）快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式一：左右互相填充，求出标杆所在的位置，标杆左边小于它，右边大于它</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> arr[l];<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; x) r--;<br>        arr[l] = arr[r];<br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt;= x) l++;<br>        arr[r] = arr[l];<br>    &#125;<br>    arr[l] = x;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">qSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> partition(arr, l, r);<br>    qSort(arr, l, pos - <span class="hljs-number">1</span>);<br>    quickSort(arr, pos + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-comment">// 方式二直接一个函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = r, x = arr[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span> (arr[i] &lt; x) i++;<br>        <span class="hljs-keyword">while</span> (arr[j] &gt; x) j--;<br>        <span class="hljs-keyword">if</span> (i &lt;= j) &#123;<br>            swap(arr, i, j);<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &lt; j) quickSort(arr, l, j);<br>    <span class="hljs-keyword">if</span> (i &lt; r) quickSort(arr, i, r);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="（四）归并排序"><a href="#（四）归并排序" class="headerlink" title="（四）归并排序"></a>（四）归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSrt</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        mergeSrt(arr, l, mid);<br>        mergeSrt(arr, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r - l + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;<br>                tmp[idx++] = arr[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp[idx++] = arr[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[idx++] = arr[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= r) tmp[idx++] = arr[j++];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; idx; k ++ ) &#123;<br>            arr[l + k] = tmp[k];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="（五）堆排序"><a href="#（五）堆排序" class="headerlink" title="（五）堆排序"></a>（五）堆排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= r &amp;&amp; arr[j + <span class="hljs-number">1</span>] &gt; arr[j]) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[i]) &#123;<br>            swap(arr, j, i);<br>            i = j;<br>            j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 建堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) &#123;<br>        down(arr, i, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i -- ) &#123;<br>        swap(arr, <span class="hljs-number">0</span>, i);<br>        down(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="（六）直接插入排序"><a href="#（六）直接插入排序" class="headerlink" title="（六）直接插入排序"></a>（六）直接插入排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i], j;<br>        <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; tmp; j -- ) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="（七）折半插入排序"><a href="#（七）折半插入排序" class="headerlink" title="（七）折半插入排序"></a>（七）折半插入排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">halfInsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i], j;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = i;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (arr[mid] &lt;= tmp) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= l; j -- ) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="（八）-希尔排序"><a href="#（八）-希尔排序" class="headerlink" title="（八） 希尔排序"></a>（八） 希尔排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">dk</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>; dk &gt;= <span class="hljs-number">1</span>; dk /= <span class="hljs-number">2</span> ) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> dk; i &lt; n; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i - dk] &gt; arr[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i], j;<br>                <span class="hljs-keyword">for</span> (j = i - dk; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; tmp; j -= dk ) &#123;<br>                    arr[j + dk] = arr[j];<br>                &#125;<br>                arr[j + dk] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>算法模板</category>
        <category>排序算法模板</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题总结</title>
    <url>/2022/11/25/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="背包问题总结"></a>背包问题总结</h2><h3 id="（1）-背包问题递推公式"><a href="#（1）-背包问题递推公式" class="headerlink" title="（1） 背包问题递推公式"></a>（1） 背包问题递推公式</h3><p><img src="/2022/11/25/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F.png" alt="背包问题递推公式"></p>
<h3 id="（2）背包问题遍历顺序"><a href="#（2）背包问题遍历顺序" class="headerlink" title="（2）背包问题遍历顺序"></a>（2）背包问题遍历顺序</h3><p><img src="/2022/11/25/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F.png" alt="背包问题遍历顺序"></p>
<h3 id="（3）背包问题具体代码"><a href="#（3）背包问题具体代码" class="headerlink" title="（3）背包问题具体代码"></a>（3）背包问题具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">背包问题总结 (一般OJ的数组从<span class="hljs-number">0</span>开始， 第一层<span class="hljs-keyword">for</span>循环可以修改为<span class="hljs-number">0</span>开始，下面不变)<br><span class="hljs-number">1</span>、存在型背包： f[j] = f[j] || f[j - v[i]]<br><span class="hljs-number">2</span>、价值型背包： f[j] = max(f[j], f[j - v[i]] + w[i]) <br>				f[j] = max(f[j], f[j - k * v[i]] + k * w[i]) <br><span class="hljs-number">3</span>、方案数型背包： f[j] += f[j - v[i]]<br><span class="hljs-number">4</span>、概率型背包   f[j] = min(f[j], f[j - v[i]] * (<span class="hljs-number">1.0</span> - probability[i])) <br>				 <span class="hljs-comment">//f[j] 表示前i个学校，本金j不中的概率（全部不中） </span><br><br>背包一（存在型<span class="hljs-number">01</span>背包）f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  f[<span class="hljs-number">1</span> ~ m] = <span class="hljs-number">0</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= A[i - <span class="hljs-number">1</span>]; j -- ) &#123;<br>                f[j] = f[j] || f[j - A[i - <span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br><br>背包二 (价值型<span class="hljs-number">01</span>背包) f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>   f[<span class="hljs-number">1</span> ~ m] = <span class="hljs-number">0</span> 体积小于等于i的赋值， 不需遍历 f[m] <br>					  f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>   f[<span class="hljs-number">1</span> ~ m] = INF(求最小)/-INF(求最大) 体积恰好为i，要遍历 <br>						<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= v[i - <span class="hljs-number">1</span>]; j -- ) &#123;<br>				f[j] = max(f[j], f[j - v[i - <span class="hljs-number">1</span>]] + w[i - <span class="hljs-number">1</span>]); <br>			&#125; <br>		&#125;<br>背包三 （价值型完全背包）f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>   f[<span class="hljs-number">1</span> ~ m] = <span class="hljs-number">0</span> 体积小于等于i的赋值， 不需遍历 f[m] <br>					     f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>   f[<span class="hljs-number">1</span> ~ m] = INF(求最小)/-INF(求最大) 体积恰好为i，要遍历 <br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> v[i - <span class="hljs-number">1</span>]; j &lt;= m; j ++ ) &#123;<br>                f[j] = max(f[j], f[j - v[i - <span class="hljs-number">1</span>]] + w[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <br>        (价值型多重背包) f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>   f[<span class="hljs-number">1</span> ~ m] = <span class="hljs-number">0</span> 体积小于等于i的赋值， 不需遍历 f[m] <br>					     f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>   f[<span class="hljs-number">1</span> ~ m] = INF(求最小)/-INF(求最大) 体积恰好为i，要遍历 <br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &lt;= v[i]; j ++ ) &#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ ) &#123;<br>					f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);<br>				&#125;<br>			&#125;<br>		&#125; <br><br>背包四 （方案型完全背包：无限次 + 无顺序）f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>   f[<span class="hljs-number">1</span> ~ m] = <span class="hljs-number">0</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> A[i - <span class="hljs-number">1</span>]; j &lt;= m; j ++ ) &#123;<br>                f[j] += f[j - A[i - <span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果求组合数就是外层for循环遍历物品，内层for遍历背包。</span><br><span class="hljs-comment">如果求排列数就是外层for遍历背包，内层for循环遍历物品。</span><br><span class="hljs-comment">*/</span><br> <br>背包五 （方案型<span class="hljs-number">01</span>背包：只有一次）f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    f[<span class="hljs-number">1</span> ~ m] = <span class="hljs-number">0</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= A[i - <span class="hljs-number">1</span>]; j -- ) &#123;<br>                f[j] += f[j - A[i - <span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br><br>背包六 （方案型完全背包：无限次 + 有顺序）	 f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>   f[<span class="hljs-number">1</span> ~ m] = <span class="hljs-number">0</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j ++ ) &#123;  <span class="hljs-comment">//先遍历体积</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123; <span class="hljs-comment">//再遍历物品 </span><br>                <span class="hljs-keyword">if</span>(j &gt;= A[i - <span class="hljs-number">1</span>]) &#123;<br>                    f[j] += f[j - A[i - <span class="hljs-number">1</span>]];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>背包七	（多重背包:珍爱生活）<br>		cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= v[i]; j -- ) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ ) &#123;<br>                    f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);<br>                &#125;<br>            &#125;<br>        &#125; <br>	<br><br>背包八 统计方案数 （f[i] 表示能否组成i, 另外开数组统计硬币数目） <br>		（给一些不同价值和数量的硬币。找出这些硬币可以组合在<span class="hljs-number">1</span> ~ n范围内的值的数量） <br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">cnt</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> v[i]; j &lt;= m; j ++ ) &#123;<br>                <span class="hljs-keyword">if</span>(!f[j] &amp;&amp; f[j - v[i]] &amp;&amp; cnt[j - v[i]] &lt; s[i]) &#123;<br>                    f[j] = <span class="hljs-number">1</span>;<br>                    cnt[j] += cnt[j - v[i]] + <span class="hljs-number">1</span>;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>      <br>背包九  （概率背包）<br>	   vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title function_">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-number">1.0</span>)</span>;  <span class="hljs-comment">//前i个学校， 有n元时， 没有offer的最低概率</span><br>       <br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123; <span class="hljs-comment">//0-1背包问题</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= v[i]; j -- ) &#123;<br>               f[j] = min(f[j], f[j - v[i]] * (<span class="hljs-number">1.0</span> - probability[i]));<br>           &#125;<br>       &#125;<br>       <br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - f[m];        <br><br>背包十  （完全背包变形之给小费：总 - max f[i]） <br>		<span class="hljs-type">int</span> v[<span class="hljs-number">3</span>] = &#123;a, b, c&#125;; <br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> v[i]; j &lt;= m; j ++ ) &#123;<br>                f[j] = max(f[j], f[j - v[i]] + v[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> m - f[m];<br><br>背包变形<br><span class="hljs-number">1</span>】  <span class="hljs-number">0</span>-<span class="hljs-number">1</span>背包问题的路径打印 （<span class="hljs-number">0</span>-<span class="hljs-number">1</span>背包的路径打印 （字典序最小如： <span class="hljs-number">123</span> &lt; <span class="hljs-number">31</span>）） <br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">1</span>; i -- ) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= m; j ++ ) &#123;<br>            f[i][j] = f[i + <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) &#123;<br>                f[i][j] = max(f[i][j], f[i + <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>        <span class="hljs-keyword">if</span>(j &gt;= v[i] &amp;&amp; f[i][j] == f[i + <span class="hljs-number">1</span>][j - v[i]] + w[i]) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j -= v[i];<br>        &#125;<br>    &#125; <br><span class="hljs-number">2</span>】  <span class="hljs-number">0</span>-<span class="hljs-number">1</span>背包最大价值的方案数  <br>const <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">1010</span>, INF = <span class="hljs-number">1e9</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> f[N], g[N]; <span class="hljs-comment">//f[i]表示容量恰好为i时的价值， g[i]表示该容量的方案数</span><br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//方案</span><br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//价值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i ++ ) f[i] = -INF;   <span class="hljs-comment">//恰好为, 求最大值 </span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= v[i]; j -- ) &#123;<br>            <span class="hljs-comment">// f[j] = max(f[j], f[j - v[i]] + w[i]); 相当于拆开统计</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxv</span> <span class="hljs-operator">=</span> max(f[j], f[j - v[i]] + w[i]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(maxv == f[j]) cnt += g[j];<br>            <span class="hljs-keyword">if</span>(maxv == f[j - v[i]] + w[i]) cnt += g[j - v[i]];<br>            g[j] = cnt % mod;<br>            f[j] = maxv;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i ++ ) res = max(res, f[i]);<br>    <span class="hljs-comment">// cout &lt;&lt; res &lt;&lt; endl;</span><br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i ++ ) &#123;<br>        <span class="hljs-keyword">if</span>(res == f[i]) &#123;<br>            cnt = (cnt + g[i]) % mod;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br><br><br> <br>============================================================= <br><span class="hljs-number">1</span>）背包一：（求最大重量，<span class="hljs-number">01</span>背包存在性问题） <br>在n个物品中挑选若干物品装入背包，最多能装多满？<br>假设背包的大小为m，每个物品的大小为A[i] <br><br>样例 <span class="hljs-number">1</span>:<br>	输入:  [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>], backpack size=<span class="hljs-number">10</span><br>	输出:  <span class="hljs-number">9</span><br><br>样例 <span class="hljs-number">2</span>:<br>	输入:  [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>], backpack size=<span class="hljs-number">12</span><br>	输出:  <span class="hljs-number">12</span><br>	<br>	<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m: An integer m denotes the size of a backpack</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> A: Given n items with size A[i]</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: The maximum size</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">backPack</span><span class="hljs-params">(<span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt; &amp;A)</span> &#123;<br>        <span class="hljs-comment">// int n = A.size();</span><br>        <br>        <span class="hljs-comment">// if(n == 0) &#123;</span><br>        <span class="hljs-comment">//     return 0;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// int f[n + 1][m + 1];</span><br>        <br>        <span class="hljs-comment">// for(int i = 1; i &lt;= m; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     f[0][i] = 0;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// f[0][0] = 1;</span><br>        <br>        <span class="hljs-comment">// for(int i = 1; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     for(int j = 0; j &lt;= m; j ++ ) &#123;</span><br>        <span class="hljs-comment">//         f[i][j] = f[i - 1][j];</span><br>        <span class="hljs-comment">//         if(j &gt;= A[i - 1]) &#123;</span><br>        <span class="hljs-comment">//             f[i][j] = f[i][j] || f[i - 1][j - A[i - 1]];</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// for(int i = m; i &gt;= 0; i -- ) &#123;</span><br>        <span class="hljs-comment">//     if(f[n][i]) &#123;</span><br>        <span class="hljs-comment">//         return i;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// return 0;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> A.size();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        bool f[m + <span class="hljs-number">1</span>]; <span class="hljs-comment">//能否装体积恰好是i</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i ++ ) f[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">//恰好装满体积i的初始条件</span><br>        <br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= A[i - <span class="hljs-number">1</span>]; j -- ) &#123;<br>                f[j] = f[j] || f[j - A[i - <span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &gt;= <span class="hljs-number">0</span>; i -- ) &#123;<br>            <span class="hljs-keyword">if</span>(f[i] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-number">2</span>）背包二：（求价值， <span class="hljs-number">01</span>背包） <br>有 n 个物品和一个大小为 m 的背包. <br>给定数组 A 表示每个物品的大小和数组 V 表示每个物品的价值.<br>问最多能装入背包的总价值是多大? 每个物品只能取一次<br><br>样例 <span class="hljs-number">1</span>:<br><br>输入: m = <span class="hljs-number">10</span>, A = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>], V = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br>输出: <span class="hljs-number">9</span><br>解释: 装入 A[<span class="hljs-number">1</span>] 和 A[<span class="hljs-number">3</span>] 可以得到最大价值, V[<span class="hljs-number">1</span>] + V[<span class="hljs-number">3</span>] = <span class="hljs-number">9</span> <br>样例 <span class="hljs-number">2</span>:<br><br>输入: m = <span class="hljs-number">10</span>, A = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>], V = [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]<br>输出: <span class="hljs-number">10</span><br>解释: 装入 A[<span class="hljs-number">0</span>] 和 A[<span class="hljs-number">2</span>] 可以得到最大价值, V[<span class="hljs-number">0</span>] + V[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m: An integer m denotes the size of a backpack</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> A: Given n items with size A[i]</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> V: Given n items with value V[i]</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: The maximum value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">backPackII</span><span class="hljs-params">(<span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, vector&lt;<span class="hljs-type">int</span>&gt; &amp;w)</span> &#123;<br>        <span class="hljs-keyword">if</span>(v.empty() || w.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> v.size();<br>        <br>        <span class="hljs-type">int</span> f[m + <span class="hljs-number">1</span>];  <span class="hljs-comment">//体积为 i 的最大价值（可以不装满）</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i ++ ) &#123;<br>            f[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= v[i - <span class="hljs-number">1</span>]; j -- ) &#123;<br>                f[j] = max(f[j], f[j - v[i - <span class="hljs-number">1</span>]] + w[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> f[m];<br>        <span class="hljs-comment">// if(v.empty() || w.empty()) return 0;</span><br>        <br>        <span class="hljs-comment">// int n = v.size();</span><br>        <br>        <span class="hljs-comment">// int f[n + 1][m + 1];  //f[i][j] 表示前 i 物品,组成 体积为 j的最大价值 </span><br>        <br>        <span class="hljs-comment">// for(int i = 1; i &lt;= m; i ++ ) f[0][i] = -1;</span><br>        <br>        <span class="hljs-comment">// f[0][0] = 0;</span><br>        <span class="hljs-comment">// for(int i = 1; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     for(int j = 0; j &lt;= m; j ++ ) &#123;</span><br>        <span class="hljs-comment">//         f[i][j] = f[i - 1][j];</span><br>        <span class="hljs-comment">//         if(j &gt;= v[i - 1] &amp;&amp; f[i - 1][j - v[i - 1]] != -1) &#123;</span><br>        <span class="hljs-comment">//             f[i][j] = max(f[i][j], f[i - 1][j - v[i - 1]] + w[i - 1]);</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// int res = 0;</span><br>        <span class="hljs-comment">// for(int i = 0; i &lt;= m; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     res = max(res, f[n][i]);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// return res;</span><br>        <br>        <span class="hljs-comment">// int n = v.size();</span><br>        <br>        <span class="hljs-comment">// if(n == 0) &#123;</span><br>        <span class="hljs-comment">//     return 0;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// int f[n + 1][m + 1];</span><br>        <span class="hljs-comment">// int g[n + 1][m + 1];</span><br>        <br>        <span class="hljs-comment">// f[0][0] = 0;</span><br>        <span class="hljs-comment">// for(int i = 1; i &lt;= m ;i ++ ) &#123;</span><br>        <span class="hljs-comment">//     f[0][i] = 0;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// for(int i = 1; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     for(int j = 0; j &lt;= m; j ++ ) &#123;</span><br>        <span class="hljs-comment">//         f[i][j] = f[i - 1][j];</span><br>        <span class="hljs-comment">//         g[i][j] = 0;</span><br>        <span class="hljs-comment">//         if(j &gt;= v[i - 1]) &#123;</span><br>        <span class="hljs-comment">//             f[i][j] = max(f[i][j], f[i - 1][j - v[i - 1]] + w[i - 1]);</span><br>        <span class="hljs-comment">//             if(f[i][j] == f[i - 1][j - v[i - 1]] + w[i - 1]) &#123;</span><br>        <span class="hljs-comment">//                 g[i][j] = 1;</span><br>        <span class="hljs-comment">//             &#125;</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// int j = m;</span><br>        <span class="hljs-comment">// int path[n];</span><br>        <span class="hljs-comment">// for(int i = n; i &gt;= 1; i -- ) &#123;</span><br>        <span class="hljs-comment">//     if(g[i][j] == 1) &#123;</span><br>        <span class="hljs-comment">//         path[i - 1] = true;</span><br>        <span class="hljs-comment">//         j -= v[i - 1];</span><br>        <span class="hljs-comment">//     &#125; else &#123;</span><br>        <span class="hljs-comment">//         path[i - 1] = false;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// for(int i = 0; i &lt; n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     // if(path[i] == 1) &#123;</span><br>        <span class="hljs-comment">//     //     printf(&quot;%d %d\n&quot;,v[i], w[i]);</span><br>        <span class="hljs-comment">//     // &#125;</span><br>        <span class="hljs-comment">//   if(path[i] == 1) &#123;</span><br>        <span class="hljs-comment">//       cout &lt;&lt; &quot;item &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; v[i] &lt;&lt; &quot; &quot; &lt;&lt; w[i] &lt;&lt; endl;</span><br>        <span class="hljs-comment">//   &#125;</span><br>        <span class="hljs-comment">// &#125; </span><br><br>        <span class="hljs-comment">// return f[n][m];</span><br>        <span class="hljs-comment">// int n = v.size();</span><br>        <span class="hljs-comment">// if(n == 0) &#123;</span><br>        <span class="hljs-comment">//     return 0;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// int f[m + 1];</span><br>        <br>        <span class="hljs-comment">// memset(f, 0, sizeof(f));</span><br>        <br>        <span class="hljs-comment">// for(int i = 1; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     for(int j = m; j &gt;= v[i - 1]; j -- ) &#123;</span><br>        <span class="hljs-comment">//         f[j] = max(f[j], f[j - v[i - 1]] + w[i - 1]);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// return f[m];</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-number">3</span>）背包三：（完全背包问题） <br>给定 n 种物品, 每种物品都有无限个. 第 i 个物品的体积为 A[i], 价值为 V[i].<br><br>再给定一个容量为 m 的背包. 问可以装入背包的最大价值是多少?<br><br>样例 <span class="hljs-number">1</span>:<br><br>输入: A = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>], V = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>], m = <span class="hljs-number">10</span><br>输出: <span class="hljs-number">15</span><br>解释: 装入三个物品 <span class="hljs-number">1</span> (A[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>, V[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>), 总价值 <span class="hljs-number">15.</span><br>样例 <span class="hljs-number">2</span>:<br><br>输入: A = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], V = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], m = <span class="hljs-number">5</span><br>输出: <span class="hljs-number">5</span><br>解释: 策略不唯一. 比如, 装入五个物品 <span class="hljs-number">0</span> (A[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, V[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>). <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> A: an integer array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> V: an integer array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m: An integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: an array</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">backPackIII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, vector&lt;<span class="hljs-type">int</span>&gt; &amp;w, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-keyword">if</span>(v.empty() || w.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> v.size();<br>        <br>        <span class="hljs-type">int</span> f[m + <span class="hljs-number">1</span>];   <span class="hljs-comment">//f[i] 表示背包体积是 i 的最大价值（背包体积可以不装满）</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i ++ ) &#123;<br>            f[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> v[i - <span class="hljs-number">1</span>]; j &lt;= m; j ++ ) &#123;<br>                f[j] = max(f[j], f[j - v[i - <span class="hljs-number">1</span>]] + w[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> f[m];<br>        <br>        <span class="hljs-comment">// int n = v.size();</span><br>        <br>        <span class="hljs-comment">// if(n == 0) &#123;</span><br>        <span class="hljs-comment">//     return 0;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// int f[n + 1][m + 1];</span><br>        <br>        <span class="hljs-comment">// memset(f, 0, sizeof(f)); </span><br>        <br>        <span class="hljs-comment">// for(int i = 1; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     for(int j = 0; j &lt;= m; j ++ ) &#123;</span><br>        <span class="hljs-comment">//         for(int k = 0; k * v[i - 1] &lt;= j; k ++ ) &#123;</span><br>        <span class="hljs-comment">//             f[i][j] = max(f[i][j], f[i - 1][j - v[i - 1] * k] + w[i - 1] * k);</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// return f[n][m];</span><br>    &#125;<br>&#125;;<br><br>背包三-<span class="hljs-number">2</span> 多重背包问题<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= v[i]; j -- ) &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k ++ ) &#123;<br>				f[j] = max(f[j], f[j - v[i] * k] + w[i] * k);<br>			&#125;<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; f[m]; <br><br><span class="hljs-number">4</span>）背包四 （无限次 + 不考虑顺序） <br>给出 n 个物品, 以及一个数组, nums[i]代表第i个物品的大小, <br>保证大小均为正数并且没有重复, 正整数 target 表示背包的大小, <br>找到能填满背包的方案数。<br>每一个物品可以使用无数次<br><br>样例<span class="hljs-number">1</span><br><br>输入: nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] 和 target = <span class="hljs-number">7</span><br>输出: <span class="hljs-number">2</span><br>解释:<br>方案有: <br>[<span class="hljs-number">7</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>样例<span class="hljs-number">2</span><br><br>输入: nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 和 target = <span class="hljs-number">7</span><br>输出: <span class="hljs-number">3</span><br>解释:<br>方案有: <br>[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums: an integer array and all positive numbers, no duplicates</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target: An integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: An integer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">backPackIV</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> m)</span> &#123;<br>        <br>        <span class="hljs-comment">// vector&lt;int&gt; dp(target + 1);</span><br>        <span class="hljs-comment">// dp[0] = 1;</span><br>        <span class="hljs-comment">// for (auto a : nums) &#123;</span><br>        <span class="hljs-comment">//     for (int i = a; i &lt;= target; ++i) &#123;</span><br>        <span class="hljs-comment">//         dp[i] += dp[i - a];</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return dp.back();</span><br>        <br>        <span class="hljs-keyword">if</span>(A.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> A.size();<br>        <br>        <span class="hljs-type">int</span> f[m + <span class="hljs-number">1</span>]; <span class="hljs-comment">// f[i] 表示恰好体积为 i 的方案数</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i ++ ) &#123;<br>            f[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> A[i - <span class="hljs-number">1</span>]; j &lt;= m; j ++ ) &#123;<br>                f[j] += f[j - A[i - <span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br>    <br>        <span class="hljs-keyword">return</span> f[m];<br>       <br>     &#125;<br>     <br>&#125;;<br><br><br><span class="hljs-number">5</span>）背包五 （只能用一次） <br>给出 n 个物品, 以及一个数组, nums[i] 代表第i个物品的大小, 保证大小均为正数,<br> 正整数 target 表示背包的大小, 找到能填满背包的方案数。<br>每一个物品只能使用一次<br><br>样例<br>给出候选物品集合 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>] 以及 target <span class="hljs-number">7</span><br><br>结果的集合为:<br>[<span class="hljs-number">7</span>]<br>[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>返回 <span class="hljs-number">2</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums: an integer array and all positive numbers</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target: An integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: An integer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">backPackV</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-comment">// int n = A.size();</span><br>        <br>        <span class="hljs-comment">// if(n == 0) &#123;</span><br>        <span class="hljs-comment">//     return 0;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// int f[n + 1][m + 1]; //前i 个物品拼出 重量位j的方式数目（不是存在性）</span><br>        <br>        <span class="hljs-comment">// f[0][0] = 1;</span><br>        <span class="hljs-comment">// //前0个物品拼不出任何重量[1 ~ m] </span><br>        <span class="hljs-comment">// for(int i = 1; i &lt;= m; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     f[0][i] = 0; </span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// for(int i = 1; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     for(int j = 0; j &lt;= m; j ++ ) &#123;</span><br>        <span class="hljs-comment">//         f[i][j] = f[i - 1][j];</span><br>        <span class="hljs-comment">//         if(j &gt;= A[i - 1]) &#123;</span><br>        <span class="hljs-comment">//             // f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);   //0~1背包问题</span><br>        <span class="hljs-comment">//             f[i][j] = f[i][j] + f[i - 1][j - A[i - 1]];</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// return f[n][m];</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        vector&lt;int&gt; dp(target + 1);</span><br><span class="hljs-comment">        dp[0] = 1;</span><br><span class="hljs-comment">        for (auto a : nums) &#123;</span><br><span class="hljs-comment">            for (int i = target; i &gt;= a; --i) &#123;</span><br><span class="hljs-comment">                dp[i] += dp[i - a];</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return dp.back();</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// int n = A.size();</span><br>        <br>        <span class="hljs-comment">// if(n == 0) &#123;</span><br>        <span class="hljs-comment">//     return 0;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// int f[m + 1];</span><br>        <br>        <span class="hljs-comment">// f[0] = 1;</span><br>        <br>        <span class="hljs-comment">// for(int i = 1; i &lt;= m; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     f[i] = 0;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// for(int i = 1; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     for(int j = m; j &gt;= A[i - 1]; j -- ) &#123;</span><br>        <span class="hljs-comment">//         f[j] += f[j - A[i - 1]];</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-comment">// return f[m];</span><br>        <span class="hljs-keyword">if</span>(A.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> A.size();<br>        <br>        <span class="hljs-type">int</span> f[m + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 01背包， f[i] 表示体积恰好为i的方案数目</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i ++ ) &#123;<br>            f[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= A[i - <span class="hljs-number">1</span>]; j -- ) &#123;<br>                f[j] += f[j - A[i - <span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> f[m];<br>    &#125;<br>&#125;;<br><br><span class="hljs-number">6</span>） 背包六 （无限次 + 考虑顺序） <br>给出一个都是正整数的数组 nums，其中没有重复的数。<br>从中找出所有的和为 target 的组合个数。<br>一个数可以在组合中出现多次。<br>数的顺序不同则会被认为是不同的组合。<br><br>样例<span class="hljs-number">1</span><br><br>输入: nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>] 和 target = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">6</span><br>解释:<br>可能的所有组合有：<br>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">4</span>]<br>样例<span class="hljs-number">2</span><br><br>输入: nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] 和 target = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">5</span><br>解释:<br>可能的所有组合有：<br>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums: an integer array and all positive numbers, no duplicates</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target: An integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: An integer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">backPackVI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        vector&lt;int&gt; dp(target + 1);</span><br><span class="hljs-comment">        dp[0] = 1;</span><br><span class="hljs-comment">        for (int i = 1; i &lt;= target; ++i) &#123;</span><br><span class="hljs-comment">            for (auto a : nums)</span><br><span class="hljs-comment">            if (i &gt;= a) &#123;</span><br><span class="hljs-comment">                dp[i] += dp[i - a];</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return dp.back();</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(A.empty() || A.size() == <span class="hljs-number">0</span> || m == <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> f[m + <span class="hljs-number">1</span>];  <span class="hljs-comment">//体积为恰好为 i 的，的无限次的，有顺序的方案数</span><br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> A.size();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m ; i ++ ) &#123;<br>            f[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j ++ ) &#123;  <span class="hljs-comment">//先遍历体积</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>                <span class="hljs-keyword">if</span>(j &gt;= A[i - <span class="hljs-number">1</span>]) &#123;<br>                    f[j] += f[j - A[i - <span class="hljs-number">1</span>]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> f[m];<br>    &#125;<br>&#125;;<br><br><span class="hljs-number">7</span>）背包 VII （多重背包） <br><br>假设你身上有 n 元，超市里有多种大米可以选择，每种大米都是袋装的，必须整袋购买，<br>给出每种大米的价格，重量以及数量，求最多能买多少公斤的大米<br><br>样例 <span class="hljs-number">1</span>:<br><br>输入:  n = <span class="hljs-number">8</span>, prices = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>], weights = [<span class="hljs-number">300</span>,<span class="hljs-number">160</span>], amounts = [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>]<br>输出:  <span class="hljs-number">640</span>	<br>解释:  全买价格为<span class="hljs-number">2</span>的米。<br>样例 <span class="hljs-number">2</span>:<br><br>输入:  n = <span class="hljs-number">8</span>, prices  = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], weight = [<span class="hljs-number">100</span>,<span class="hljs-number">100</span>], amounts = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span> ]<br>输出:  <span class="hljs-number">400</span>	<br>解释:  全买价格为<span class="hljs-number">2</span>的米	<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n: the money of you</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prices: the price of rice[i]</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> weight: the weight of rice[i]</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amounts: the amount of rice[i]</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: the maximum weight</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">backPackVII</span><span class="hljs-params">(<span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, vector&lt;<span class="hljs-type">int</span>&gt; &amp;w, vector&lt;<span class="hljs-type">int</span>&gt; &amp;s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(w.empty() || v.empty() || s.empty()|| m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> v.size();<br>        <br>        vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span>;<br>        <br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i ++ ) f[i] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= v[i]; j -- ) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ ) &#123;<br>                    f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m];<br>    &#125;<br>&#125;; <br><br><span class="hljs-number">8</span>）背包 VIII<br>给一些不同价值和数量的硬币。找出这些硬币可以组合在<span class="hljs-number">1</span> ~ n范围内的值的数量<br><br>样例 <span class="hljs-number">1</span>:<br>	输入:  <br>		n = <span class="hljs-number">5</span><br>		value = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>		amount = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>	输出:  <span class="hljs-number">4</span><br>	<br>	解释:<br>	可以组合出<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span><br><br>样例 <span class="hljs-number">2</span>:<br>	输入: <br>		n = <span class="hljs-number">10</span><br>		value = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br>		amount = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>	输出:  <span class="hljs-number">8</span><br>	<br>	解释:<br>	可以组合出<span class="hljs-number">1</span>-<span class="hljs-number">8</span>所有数字。<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n: the value from 1 - n</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value: the value of coins</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount: the number of coins</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: how many different value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">backPackVIII</span><span class="hljs-params">(<span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, vector&lt;<span class="hljs-type">int</span>&gt; &amp;s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> v.size();<br>        <br>        vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>; <span class="hljs-comment">// 是否存在方案，组成m</span><br>        <br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i ++ ) f[i] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">cnt</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> v[i]; j &lt;= m; j ++ ) &#123;<br>                <span class="hljs-keyword">if</span>(!f[j] &amp;&amp; f[j - v[i]] &amp;&amp; cnt[j - v[i]] &lt; s[i]) &#123;<br>                    f[j] = <span class="hljs-number">1</span>;<br>                    cnt[j] += cnt[j - v[i]] + <span class="hljs-number">1</span>;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-number">9</span>）背包 IX（概率）<br><br>你总共有n元，商人总共有三种商品，它们的价格分别是<span class="hljs-number">150</span>元,<span class="hljs-number">250</span>元,<span class="hljs-number">350</span>元，<br>三种商品的数量可以认为是无限多的，购买完商品以后需要将剩下的钱给商人作为小费，<br>求最少需要给商人多少小费<br><br>您在真实的面试中是否遇到过这个题？  <br>样例<br>样例 <span class="hljs-number">1</span>:<br><br>输入:  n = <span class="hljs-number">900</span><br>输出:  <span class="hljs-number">0</span><br>样例 <span class="hljs-number">2</span>:<br><br>输入:  n = <span class="hljs-number">800</span><br>输出:  <span class="hljs-number">0</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n: Your money</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prices: Cost of each university application</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> probability: Probability of getting the University&#x27;s offer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: the  highest probability</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">backpackIX</span><span class="hljs-params">(<span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, vector&lt;<span class="hljs-type">double</span>&gt; &amp;probability)</span> &#123;<br>       <span class="hljs-comment">//至少获得一份offer的最高可能 = 1 - 全部都获取不了的最低可能</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> v.size();<br>       <br>       vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title function_">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-number">1.0</span>)</span>;  <span class="hljs-comment">//前i个学校， 有n元时， 没有offer的最低概率</span><br>       <br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123; <span class="hljs-comment">//0-1背包问题</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= v[i - <span class="hljs-number">1</span>]; j -- ) &#123;<br>               f[j] = min(f[j], f[j - v[i - <span class="hljs-number">1</span>]] * (<span class="hljs-number">1.0</span> - probability[i - <span class="hljs-number">1</span>]));<br>           &#125;<br>       &#125;<br>       <br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - f[m];<br>    &#125;<br>&#125;; <br><br><span class="hljs-number">10</span>）背包 X <br>你总共有n元，商人总共有三种商品，它们的价格分别是<span class="hljs-number">150</span>元,<span class="hljs-number">250</span>元,<span class="hljs-number">350</span>元，<br>三种商品的数量可以认为是无限多的，购买完商品以后需要将剩下的钱给商人作为小费，<br>求最少需要给商人多少小费<br><br>样例<br>样例 <span class="hljs-number">1</span>:<br><br>输入:  n = <span class="hljs-number">900</span><br>输出:  <span class="hljs-number">0</span><br>样例 <span class="hljs-number">2</span>:<br><br>输入:  n = <span class="hljs-number">800</span><br>输出:  <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n: the money you have</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: the minimum money you have to give</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">backPackX</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> v[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">150</span>, <span class="hljs-number">250</span>, <span class="hljs-number">350</span>&#125;;<br>        <span class="hljs-comment">//最少给小费，即求最大消费 (m - f[m])</span><br>        <br>        vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span>;<br>        <br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i ++ ) f[i] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> v[i]; j &lt;= m; j ++ ) &#123;<br>                f[j] = max(f[j], f[j - v[i]] + v[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> m - f[m];<br>    &#125;<br>&#125;;<br><br><span class="hljs-number">11</span>） <span class="hljs-number">0</span>-<span class="hljs-number">1</span>背包问题的路径打印 （<span class="hljs-number">0</span>-<span class="hljs-number">1</span>背包的路径打印 （字典序最小如： <span class="hljs-number">123</span> &lt; <span class="hljs-number">31</span>）） <br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">1</span>; i -- ) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= m; j ++ ) &#123;<br>            f[i][j] = f[i + <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) &#123;<br>                f[i][j] = max(f[i][j], f[i + <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>        <span class="hljs-keyword">if</span>(j &gt;= v[i] &amp;&amp; f[i][j] == f[i + <span class="hljs-number">1</span>][j - v[i]] + w[i]) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j -= v[i];<br>        &#125;<br>    &#125; <br><br><span class="hljs-number">12</span>)  <span class="hljs-number">0</span>-<span class="hljs-number">1</span>背包最大价值的方案数 <br>#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>const <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">1010</span>, INF = <span class="hljs-number">1e9</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N], g[N]; <span class="hljs-comment">//f[i]表示容量恰好为i时的价值， g[i]表示该容量的方案数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//方案</span><br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//价值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i ++ ) f[i] = -INF;   <span class="hljs-comment">//恰好为, 求最大值 </span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= v[i]; j -- ) &#123;<br>            <span class="hljs-comment">// f[j] = max(f[j], f[j - v[i]] + w[i]); 相当于拆开统计</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxv</span> <span class="hljs-operator">=</span> max(f[j], f[j - v[i]] + w[i]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(maxv == f[j]) cnt += g[j];<br>            <span class="hljs-keyword">if</span>(maxv == f[j - v[i]] + w[i]) cnt += g[j - v[i]];<br>            g[j] = cnt % mod;<br>            f[j] = maxv;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i ++ ) res = max(res, f[i]);<br>    <span class="hljs-comment">// cout &lt;&lt; res &lt;&lt; endl;</span><br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i ++ ) &#123;<br>        <span class="hljs-keyword">if</span>(res == f[i]) &#123;<br>            cnt = (cnt + g[i]) % mod;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>     <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题相关</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2022/11/25/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<p><img src="/2022/11/25/%E5%89%91%E6%8C%87offer/%E5%88%B7%E9%A2%98%E5%A4%A7%E7%BA%B2.webp" alt="刷题大纲.webp"></p>
<h1 id="LeetCode-lt-lt-剑指offer-gt-gt"><a href="#LeetCode-lt-lt-剑指offer-gt-gt" class="headerlink" title="LeetCode &lt;&lt;剑指offer&gt;&gt;"></a>LeetCode &lt;&lt;剑指offer&gt;&gt;</h1><h2 id="03-数组的重复的数字"><a href="#03-数组的重复的数字" class="headerlink" title="03 数组的重复的数字"></a>03 数组的重复的数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">找出数组中重复的数字。<br><br>在一个长度为 n 的数组 nums 里的所有数字都在 <span class="hljs-number">0</span> ～ n-<span class="hljs-number">1</span> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br>    <br>方式一： 原地hash<br><span class="hljs-title function_">for</span> <span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++ )</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] == i) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (nums[i] == nums[nums[i]]) <span class="hljs-keyword">return</span> nums[i];<br>    swap(nums, nums[i], nums[nums[i]]);<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.length; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] != i) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] == nums[nums[i]]) <span class="hljs-keyword">return</span> nums[i];<br>                swap(nums, i, nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = t;<br>    &#125;<br>&#125;<br><br>方式二： 排序<br>		Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>方式三： map<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>            mp.put(nums[i], mp.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (mp.get(nums[i]) &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<h2 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04 二维数组中的查找"></a>04 二维数组中的查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><br>重点：固定一维最大，另一维最小<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)<br>            	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target) &#123;<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05 替换空格"></a>05 替换空格</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">请实现一个函数，把字符串 s 中的每个空格替换成<span class="hljs-string">&quot;%20&quot;</span>。<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String ss)</span> &#123;<br>        <span class="hljs-type">char</span>[] s = ss.toCharArray();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                str.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                str.append(s[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str.toString();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06 从尾到头打印链表"></a>06 从尾到头打印链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。<br><span class="hljs-comment">// 方式一： 求全长，倒着放在数组中 </span><br><span class="hljs-comment">// 方式二:  使用栈    </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        <span class="hljs-comment">// Stack&lt;Integer&gt; st = new Stack&lt;&gt;();</span><br>        <span class="hljs-comment">// while (head != null) &#123;</span><br>        <span class="hljs-comment">//     st.push(head.val);</span><br>        <span class="hljs-comment">//     head = head.next;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// int idx = 0;</span><br>        <span class="hljs-comment">// int[] res = new int[st.size()];</span><br>        <span class="hljs-comment">// while (!st.isEmpty()) &#123;</span><br>        <span class="hljs-comment">//     res[idx++] = st.pop();</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return res;</span><br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>            n++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            res[idx--] = head.val;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07 重建二叉树"></a>07 重建二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">题目一： 从前序与中序遍历序列构造二叉树 lc105<br>前： [<span class="hljs-number">1</span>] <span class="hljs-number">2</span>  k k + <span class="hljs-number">1</span> n<br>中:  <span class="hljs-number">1</span> k - <span class="hljs-number">1</span>  [k] k + <span class="hljs-number">1</span>  n<br><span class="hljs-comment">// 优化： 中序数字的下标用hash存储</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i ++ ) &#123;<br>            mp.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> create(preorder, inorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preL, <span class="hljs-type">int</span> preR, <span class="hljs-type">int</span> inL, <span class="hljs-type">int</span> inR)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> preorder[preL];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> mp.get(root);<br>        <span class="hljs-comment">// for (k = inL; k &lt;= inR; k ++ ) &#123;</span><br>        <span class="hljs-comment">//     if (root == inorder[k]) &#123;</span><br>        <span class="hljs-comment">//         break;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numL</span> <span class="hljs-operator">=</span> k - inL;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root);<br>        node.left = create(preorder, inorder, preL + <span class="hljs-number">1</span>, preL + numL, inL, k - <span class="hljs-number">1</span>);<br>        node.right = create(preorder, inorder, preL + numL + <span class="hljs-number">1</span>, preR, k + <span class="hljs-number">1</span>, inR);<br><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br><br>题目二： 从后序与中序遍历序列构造二叉树  lc106<br>后： <span class="hljs-number">1</span>   k - <span class="hljs-number">1</span> k  n - <span class="hljs-number">1</span>  n<br>中:  <span class="hljs-number">1</span> k - <span class="hljs-number">1</span>  [k] k + <span class="hljs-number">1</span>  n <br><span class="hljs-comment">// 优化： 中序数字的下标用hash存储</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i ++ ) &#123;<br>            mp.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> create(postorder, inorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> postL, <span class="hljs-type">int</span> postR, <span class="hljs-type">int</span> inL, <span class="hljs-type">int</span> inR)</span> &#123;<br>        <span class="hljs-keyword">if</span> (postL &gt; postR) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> postorder[postR];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> mp.get(root);<br>        <span class="hljs-comment">// for (k = inL; k &lt;= inR; k ++ ) &#123;</span><br>        <span class="hljs-comment">//     if (root == inorder[k]) &#123;</span><br>        <span class="hljs-comment">//         break;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numL</span> <span class="hljs-operator">=</span> k - inL;<br>        <br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root);<br>        node.left = create(postorder, inorder, postL, postL + numL - <span class="hljs-number">1</span>, inL, k - <span class="hljs-number">1</span>);<br>        node.right = create(postorder, inorder, postL + numL, postR - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>, inR);<br><br>        <span class="hljs-keyword">return</span> node; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09 用两个栈实现队列"></a>09 用两个栈实现队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -<span class="hljs-number">1</span> )<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; st1;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; st2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        st2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        st1.push(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (st2.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (!st1.isEmpty()) &#123;<br>                st2.push(st1.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (st2.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> st2.pop();<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="09-用队列实现栈"><a href="#09-用队列实现栈" class="headerlink" title="09 用队列实现栈"></a>09 用队列实现栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; copy;<br>    Queue&lt;Integer&gt; data;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        copy.offer(x);<br>        <span class="hljs-keyword">while</span> (!data.isEmpty()) &#123;<br>            copy.offer(data.poll());<br>        &#125;<br>        Queue&lt;Integer&gt; tmp = copy;<br>        copy = data;<br>        data = tmp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data.poll();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data.peek();<br>    &#125;   <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<h2 id="10-I-斐波那契数列"><a href="#10-I-斐波那契数列" class="headerlink" title="10-I  斐波那契数列"></a>10-I  斐波那契数列</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">F(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>,   F(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br>F(N) = F(N - <span class="hljs-number">1</span>) + F(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1.</span><br>答案需要取模 <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>（<span class="hljs-number">1000000007</span>），如计算初始结果为：<span class="hljs-number">1000000008</span>，请返回 <span class="hljs-number">1</span>。<br><span class="hljs-comment">// 注意： return a 且 F[0] = 0   F[1] = 1  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// if (n == 0) return n;</span><br>        <span class="hljs-comment">// if (n == 1) return n;</span><br><br>        <span class="hljs-comment">// int[] f = new int[n + 1];</span><br>        <span class="hljs-comment">// f[0] = 0;</span><br>        <span class="hljs-comment">// f[1] = 1;</span><br>        <span class="hljs-comment">// for (int i = 2; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     f[i] = (int) (f[i - 1] + f[i - 2]) % 1000000007;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return f[n];</span><br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (a + b) % <span class="hljs-number">1000000007</span>;<br>            a = b;<br>            b = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="10-II-青蛙跳台阶问题"><a href="#10-II-青蛙跳台阶问题" class="headerlink" title="10-II 青蛙跳台阶问题"></a>10-II 青蛙跳台阶问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">一只青蛙一次可以跳上<span class="hljs-number">1</span>级台阶，也可以跳上<span class="hljs-number">2</span>级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br><br>答案需要取模 <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>（<span class="hljs-number">1000000007</span>），如计算初始结果为：<span class="hljs-number">1000000008</span>，请返回 <span class="hljs-number">1</span>。<br><br><br><span class="hljs-comment">// 注意： return b 且 F[0] = F[1] = 1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// if(n == 0 || n == 1) return 1;</span><br><br>        <span class="hljs-comment">// int[] f = new int[n + 1];</span><br>        <span class="hljs-comment">// f[0] = f[1] = 1;</span><br>        <span class="hljs-comment">// for (int i = 2; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     f[i] = (int)((f[i - 1] + f[i - 2]) % 1000000007);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return f[n];</span><br><br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (a + b) % <span class="hljs-number">1000000007</span>;<br>            a = b;<br>            b = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11 旋转数组的最小数字"></a>11 旋转数组的最小数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组  [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 的一个旋转，该数组的最小值为 <span class="hljs-number">1</span>。<br><span class="hljs-comment">// 二分法 + 去除重复</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = A.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (A[mid] &gt; A[r]) &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[mid] &lt; A[r]) &#123;<br>                r = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A[l];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12 矩阵中的路径"></a>12 矩阵中的路径</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的 <span class="hljs-number">3</span>×<span class="hljs-number">4</span> 的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。<br><br><span class="hljs-comment">// 回溯法 + 上下左右方向搜索</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] vis;<br>    <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-type">char</span>[] s = word.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j ++ ) &#123;<br>                <span class="hljs-keyword">if</span> (dfs(board, i, j, s, <span class="hljs-number">0</span>) == <span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> idx)</span> &#123;<br>        <span class="hljs-keyword">if</span> (idx == s.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= board.length || y &lt; <span class="hljs-number">0</span> || y &gt;= board[<span class="hljs-number">0</span>].length) <br>            	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (vis[x][y] || s[idx] != board[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        vis[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> X[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> Y[i] + y;<br>            <span class="hljs-keyword">if</span> (dfs(board, nx, ny, s, idx + <span class="hljs-number">1</span>) == <span class="hljs-literal">true</span>) &#123;<br>                res = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// res = dfs(board, x + 1, y, s, idx + 1) || dfs(board, x - 1, y, s, idx + 1) || </span><br>        <span class="hljs-comment">//     dfs(board, x, y + 1, s, idx + 1) || dfs(board, x, y - 1, s, idx + 1);</span><br><br>        vis[x][y] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13 机器人的运动范围"></a>13 机器人的运动范围</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">地上有一个 m 行 n 列的方格，从坐标 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] 到坐标 [m-<span class="hljs-number">1</span>,n-<span class="hljs-number">1</span>] 。一个机器人从坐标 [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 <span class="hljs-number">18</span> 时，机器人能够进入方格 [<span class="hljs-number">35</span>, <span class="hljs-number">37</span>] ，因为 <span class="hljs-number">3</span>+<span class="hljs-number">5</span>+<span class="hljs-number">3</span>+<span class="hljs-number">7</span>=<span class="hljs-number">18</span>。但它不能进入方格 [<span class="hljs-number">35</span>, <span class="hljs-number">38</span>]，因为 <span class="hljs-number">3</span>+<span class="hljs-number">5</span>+<span class="hljs-number">3</span>+<span class="hljs-number">8</span>=<span class="hljs-number">19</span>。请问该机器人能够到达多少个格子？<br><br><span class="hljs-comment">// dfs </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> m;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cnt;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] vis;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = m;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        cnt = <span class="hljs-number">0</span>;<br>        vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= m || y &lt; <span class="hljs-number">0</span> || y &gt;= n) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (vis[x][y] || getSum(x) + getSum(y) &gt; k) <span class="hljs-keyword">return</span>;<br>        cnt++;<br>        vis[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++ ) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> X[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> Y[i] + y;<br>            dfs(nx, ny);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            res += n % <span class="hljs-number">10</span>;<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="14-I-剪绳子"><a href="#14-I-剪绳子" class="headerlink" title="14-I 剪绳子"></a>14-I 剪绳子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n 都是整数，n&gt;<span class="hljs-number">1</span> 并且 m&gt;<span class="hljs-number">1</span>），每段绳子的长度记为 k[<span class="hljs-number">0</span>],k[<span class="hljs-number">1</span>]...k[m-<span class="hljs-number">1</span>] 。请问 k[<span class="hljs-number">0</span>]*k[<span class="hljs-number">1</span>]*...*k[m-<span class="hljs-number">1</span>] 可能的最大乘积是多少？例如，当绳子的长度是 <span class="hljs-number">8</span> 时，我们把它剪成长度分别为 <span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">3</span> 的三段，此时得到的最大乘积是 <span class="hljs-number">18</span>。<br><br><span class="hljs-comment">// 尽可能将绳子以长度 3 等分剪为多段时，乘积最大。    </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// if (n == 1) return 1;</span><br>        <span class="hljs-comment">// if (n == 2) return 1;</span><br>        <span class="hljs-comment">// if (n == 3) return 2;</span><br><br>        <span class="hljs-comment">// int[] f = new int[n + 1];</span><br>        <span class="hljs-comment">// f[1] = 1;</span><br>        <span class="hljs-comment">// f[2] = 2;</span><br>        <span class="hljs-comment">// f[3] = 3;</span><br>        <span class="hljs-comment">// for (int i = 4; i &lt;= n; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     for (int j = 1; j &lt;= i / 2; j ++ ) &#123;</span><br>        <span class="hljs-comment">//         f[i] = Math.max(f[i], f[j] * f[i - j]);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return f[n];</span><br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>) &#123;<br>            res *= <span class="hljs-number">3</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res * n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="14-ii-剪绳子"><a href="#14-ii-剪绳子" class="headerlink" title="14-ii 剪绳子"></a>14-ii 剪绳子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;<span class="hljs-number">1</span>并且m&gt;<span class="hljs-number">1</span>），每段绳子的长度记为 k[<span class="hljs-number">0</span>],k[<span class="hljs-number">1</span>]...k[m - <span class="hljs-number">1</span>] 。请问 k[<span class="hljs-number">0</span>]*k[<span class="hljs-number">1</span>]*...*k[m - <span class="hljs-number">1</span>] 可能的最大乘积是多少？例如，当绳子的长度是<span class="hljs-number">8</span>时，我们把它剪成长度分别为<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">3</span>的三段，此时得到的最大乘积是<span class="hljs-number">18</span>。<br><br>答案需要取模 <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>（<span class="hljs-number">1000000007</span>），如计算初始结果为：<span class="hljs-number">1000000008</span>，请返回 <span class="hljs-number">1</span>。<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>) &#123;<br>            res = (res * <span class="hljs-number">3</span>) % <span class="hljs-number">1000000007</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)((res * n) % <span class="hljs-number">1000000007</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15 二进制中1的个数"></a>15 二进制中1的个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java</span><br><span class="hljs-comment">// n &amp; (n - 1) 会消除 n 中最后一位中的 1。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= (n - <span class="hljs-number">1</span>);<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(uint32_t n)</span> &#123;<br>        <span class="hljs-type">uint32_t</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (flag) &#123;<br>            <span class="hljs-keyword">if</span> (flag &amp; n) res ++;<br>            flag &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16 数值的整数次方"></a>16 数值的整数次方</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">实现函数 <span class="hljs-type">double</span> <span class="hljs-title function_">Power</span><span class="hljs-params">(<span class="hljs-type">double</span> base, <span class="hljs-type">int</span> exponent)</span>，求 base 的 exponent 次方。不得使用库函数，同时不需要考虑大数问题。<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>        n = -n;<br>        x = <span class="hljs-number">1.0</span> / x;<br>    &#125;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) res *= x;<br>        x = x * x;<br>        n /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17 打印从1到最大的n位数"></a>17 打印从1到最大的n位数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">输入数字 n，按顺序打印出从 <span class="hljs-number">1</span> 到最大的 n 位十进制数。比如输入 <span class="hljs-number">3</span>，则打印出 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span> 一直到最大的 <span class="hljs-number">3</span> 位数 <span class="hljs-number">999</span>。<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] printNumbers(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[num];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i ++ ) &#123;<br>            res[i] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18 删除链表的节点"></a>18 删除链表的节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。<br><br><span class="hljs-comment">// 新头节点 + head（在原链表操作）</span><br><span class="hljs-comment">// 新头节点 + 原链表节点（符合条件）</span><br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyNode.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummyNode;<br><br>        <span class="hljs-keyword">while</span> (pre.next != <span class="hljs-literal">null</span> &amp;&amp; pre.next.val != val) &#123;<br>            pre = pre.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pre.next == <span class="hljs-literal">null</span>) &#123;<br>            pre.next = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre.next = pre.next.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummyNode.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19 正则表达式匹配"></a>19 正则表达式匹配</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">请实现一个函数用来匹配包含<span class="hljs-string">&#x27;. &#x27;</span>和<span class="hljs-string">&#x27;*&#x27;</span>的正则表达式。模式中的字符<span class="hljs-string">&#x27;.&#x27;</span>表示任意一个字符，而<span class="hljs-string">&#x27;*&#x27;</span>表示它前面的字符可以出现任意次（含 <span class="hljs-number">0</span> 次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<span class="hljs-string">&quot;aaa&quot;</span>与模式<span class="hljs-string">&quot;a.a&quot;</span>和<span class="hljs-string">&quot;ab*ac*a&quot;</span>匹配，但与<span class="hljs-string">&quot;aa.a&quot;</span>和<span class="hljs-string">&quot;ab*a&quot;</span>均不匹配。<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">情况一</span><br><span class="hljs-comment">f[i][j] = f[i][j] || f[i - 1][j - 1]</span><br><span class="hljs-comment">aaa</span><br><span class="hljs-comment">ba.</span><br><span class="hljs-comment">  a</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">情况二</span><br><span class="hljs-comment">f[i][j] = f[i][j] || f[i][j - 2](.* or a*表示空)</span><br><span class="hljs-comment">aaa</span><br><span class="hljs-comment">ba*</span><br><span class="hljs-comment">b.*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">f[i][j] = f[i][j] || f[i - 1][j](.* or a*表示非空)</span><br><span class="hljs-comment">*/</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String ss, String pp)</span> &#123;<br>        <span class="hljs-type">char</span>[] s = ss.toCharArray();<br>        <span class="hljs-type">char</span>[] p = pp.toCharArray();<br>        <span class="hljs-type">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length + <span class="hljs-number">1</span>][p.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= s.length; i ++ ) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= p.length; j ++ ) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>                    f[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>                    f[i][j] = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                f[i][j] = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || p[j - <span class="hljs-number">1</span>] == s[i - <span class="hljs-number">1</span>])) &#123;<br>                        f[i][j] = f[i][j] || f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">2</span>) f[i][j] = f[i][j] || f[i][j - <span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">2</span> &amp;&amp; i &gt;= <span class="hljs-number">1</span> &amp;&amp; <br>                        (p[j - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || p[j - <span class="hljs-number">2</span>] == s[i - <span class="hljs-number">1</span>])) &#123;<br>                        f[i][j] = f[i][j] || f[i - <span class="hljs-number">1</span>][j];<br>                    &#125;<br>                &#125;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> f[s.length][p.length];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20 表示数值的字符串"></a>20 表示数值的字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串<span class="hljs-string">&quot;+100&quot;</span>、<span class="hljs-string">&quot;5e2&quot;</span>、<span class="hljs-string">&quot;-123&quot;</span>、<span class="hljs-string">&quot;3.1416&quot;</span>、<span class="hljs-string">&quot;0123&quot;</span>及<span class="hljs-string">&quot;-1E-16&quot;</span>都表示数值，但<span class="hljs-string">&quot;12e&quot;</span>、<span class="hljs-string">&quot;1a3.14&quot;</span>、<span class="hljs-string">&quot;1.2.3&quot;</span>、<span class="hljs-string">&quot;+-5&quot;</span>及<span class="hljs-string">&quot;12e+5.4&quot;</span>都不是。<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">关键点： 反证法</span><br><span class="hljs-comment">出现 +/- 时，位置必须是在第 0 位，或者 e/E 的后面一位</span><br><span class="hljs-comment">出现 . 时，在此之前不能出现 . 或者 e/E</span><br><span class="hljs-comment">出现 e/E 时，前面不能出现 e/E，并且必须出现过数字</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String ss)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ss == <span class="hljs-literal">null</span> || ss.trim().length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">char</span>[] s = ss.trim().toCharArray();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasNum</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasDot</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                hasNum = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span> || s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; !(s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;E&#x27;</span> || s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;e&#x27;</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;E&#x27;</span> || s[i] == <span class="hljs-string">&#x27;e&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (hasE || !hasNum) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                hasE = <span class="hljs-literal">true</span>;<br>                hasNum = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (hasDot || hasE) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                hasDot = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21 调整数组顺序使奇数位于偶数前面"></a>21 调整数组顺序使奇数位于偶数前面</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。<br><br><span class="hljs-comment">//方式一： 开辟新数组    方式二： 类似快速排序的方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] exchange(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// int[] res = new int[nums.length];</span><br>        <span class="hljs-comment">// int idx = 0;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; nums.length; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     if (nums[i] % 2 != 0) &#123;</span><br>        <span class="hljs-comment">//         res[idx++] = nums[i];</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; nums.length; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     if (nums[i] % 2 == 0) &#123;</span><br>        <span class="hljs-comment">//         res[idx++] = nums[i];</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return res;</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) i++;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) j--;<br>            <span class="hljs-keyword">if</span> (i &lt;= j) &#123;<br>                swap(nums, i, j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = t;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22 链表中倒数第k个节点"></a>22 链表中倒数第k个节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 <span class="hljs-number">1</span> 开始计数，即链表的尾节点是倒数第 <span class="hljs-number">1</span> 个节点。例如，一个链表有 <span class="hljs-number">6</span> 个节点，从头节点开始，它们的值依次是 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">5</span>、<span class="hljs-number">6</span>。这个链表的倒数第 <span class="hljs-number">3</span> 个节点是值为 <span class="hljs-number">4</span> 的节点。<br>    <br><span class="hljs-comment">// 快慢指针    </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span>) &#123;<br>            fast = fast.next;<br>        &#125; <br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125; <br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="24-翻转链表"><a href="#24-翻转链表" class="headerlink" title="24 翻转链表"></a>24 翻转链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 方式一: 迭代法</span><br>        <span class="hljs-comment">// ListNode pre = null;</span><br>        <span class="hljs-comment">// ListNode cur = head;</span><br>        <span class="hljs-comment">// while (cur != null) &#123;</span><br>        <span class="hljs-comment">//     ListNode tmp = cur.next;</span><br>        <span class="hljs-comment">//     cur.next = pre;</span><br>        <span class="hljs-comment">//     pre = cur;</span><br>        <span class="hljs-comment">//     cur = tmp;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return pre;</span><br><br>        <span class="hljs-comment">// 方式二： 递归法</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">nHead</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> nHead;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25 合并两个排序的链表"></a>25 合并两个排序的链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 归并排序的思路</span><br><span class="hljs-comment">// 注意剩下链表的链接</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummyNode;<br><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 != <span class="hljs-literal">null</span> ? l1 : l2;<br>        <span class="hljs-keyword">return</span> dummyNode.next;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26 树的子结构"></a>26 树的子结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先判断是否相等，然后左子树是否存在，最后右子树是否存在</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">null</span> || A == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> isSubStructure(A.left, B) || isSubStructure(A.right, B) || check(A, B);    <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123; <span class="hljs-comment">// 判断是否相等</span><br>        <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">null</span> &amp;&amp; B != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br><br>        <span class="hljs-keyword">return</span> check(A.left, B.left) &amp;&amp; check(A.right, B.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27 二叉树的镜像"></a>27 二叉树的镜像</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span><br><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span>  root.left;<br>        root.left = root.right;<br>        root.right = tmp;<br><br>        mirrorTree(root.left);<br>        mirrorTree(root.right);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28 对称的二叉树"></a>28 对称的二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> isSymmetric(root.left, root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29 顺时针打印矩阵"></a>29 顺时针打印矩阵</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意不变的量，控制变量</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;&#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m * n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i ++ ) &#123;<br>                res[idx++] = matrix[t][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (++t &gt; b) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> t; i &lt;= b; i ++ ) &#123;<br>                res[idx++] = matrix[i][r];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--r &lt; l) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r; i &gt;= l; i -- ) &#123;<br>                res[idx++] = matrix[b][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--b &lt; t) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b; i &gt;= t; i -- ) &#123;<br>                res[idx++] = matrix[i][l];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (++l &gt; r) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30 包含min函数的栈"></a>30 包含min函数的栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(<span class="hljs-number">1</span>)。<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; data;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; minSt;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        minSt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        data.push(x);<br>        <span class="hljs-keyword">if</span> (minSt.isEmpty() || x &lt; minSt.peek()) &#123;<br>            minSt.push(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            minSt.push(minSt.peek());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        data.pop();<br>        minSt.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minSt.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31 栈的压入、弹出序列"></a>31 栈的压入、弹出序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。</span><br><br><span class="hljs-comment">// 直接使用栈模拟，如果栈顶等于弹出序列就弹出</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStackSequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pushed, <span class="hljs-type">int</span>[] popped)</span> &#123;<br>        Stack&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pushed.length; i ++ ) &#123;<br>            st.push(pushed[i]);<br>            <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; st.peek() == popped[j]) &#123;<br>                st.pop();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="32-i-从上到下打印二叉树"><a href="#32-i-从上到下打印二叉树" class="headerlink" title="32-i 从上到下打印二叉树"></a>32-i 从上到下打印二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。结果返回：[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br><br><span class="hljs-comment">// 层次遍历，注意返回的是int[]数组，最后需要转化</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        q.add(root);<br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> q.poll();<br>                res.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) q.offer(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) q.offer(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.size(); i ++ ) &#123;<br>            ans[i] = res.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="32-ii-从上到下打印二叉树ii"><a href="#32-ii-从上到下打印二叉树ii" class="headerlink" title="32-ii 从上到下打印二叉树ii"></a>32-ii 从上到下打印二叉树ii</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">结果返回</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  [3],</span><br><span class="hljs-comment">  [9,20],</span><br><span class="hljs-comment">  [15,7]</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        q.add(root);<br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> q.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> q.poll();<br>                list.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) q.offer(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) q.offer(node.right);<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="32-iii-从上到下打印二叉树"><a href="#32-iii-从上到下打印二叉树" class="headerlink" title="32-iii 从上到下打印二叉树"></a>32-iii 从上到下打印二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。<br>    <br><span class="hljs-comment">// 奇数行不变，偶数行逆转(Collections.reverse(list))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dep</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        q.add(root);<br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> q.size();<br>            List&lt;Integer&gt; row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            dep++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> q.poll();<br>                row.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) q.add(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) q.add(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dep % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                Collections.reverse(row);<br>                res.add(row);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.add(row);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33 二叉搜索树的后序遍历序列"></a>33 二叉搜索树的后序遍历序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回  true，否则返回  false。假设输入的数组的任意两个数字都互不相同。</span><br><span class="hljs-comment">// 关键点： 左 &lt; 中 &lt; 右</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>        <span class="hljs-keyword">while</span> (postorder[i] &lt; postorder[r]) &#123;<br>            i++;<br>        &#125; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= r - <span class="hljs-number">1</span>; j ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (postorder[j] &lt; postorder[r]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(postorder, l, i - <span class="hljs-number">1</span>) &amp;&amp; dfs(postorder, i, r - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="34-二叉树中和为某一值得路径-（路径总和II）lc113"><a href="#34-二叉树中和为某一值得路径-（路径总和II）lc113" class="headerlink" title="34 二叉树中和为某一值得路径 （路径总和II）lc113"></a>34 二叉树中和为某一值得路径 （路径总和II）lc113</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res;<br>    LinkedList&lt;Integer&gt; path;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        path.add(root.val);<br>        dfs(root, target - root.val);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; sum == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            path.add(root.left.val);<br>            sum -= root.left.val;<br>            dfs(root.left, sum);<br>            sum += root.left.val;<br>            path.removeLast();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            path.add(root.right.val);<br>            sum -= root.right.val;<br>            dfs(root.right, sum);<br>            sum += root.right.val;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="34-路径总和I-lc112"><a href="#34-路径总和I-lc112" class="headerlink" title="34 路径总和I   lc112"></a>34 路径总和I   lc112</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 <span class="hljs-literal">true</span> ；否则，返回 <span class="hljs-literal">false</span> 。<br><br>叶子节点 是指没有子节点的节点。<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> dfs(root, targetSum - root.val);    <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; sum == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            sum -= root.left.val;<br>            <span class="hljs-keyword">if</span> (dfs(root.left, sum) == <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            sum += root.left.val;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            sum -= root.right.val;<br>            <span class="hljs-keyword">if</span> (dfs(root.right, sum) == <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            sum += root.right.val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 复杂链表的复制</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 <span class="hljs-literal">null</span>。<br><br><span class="hljs-comment">// 方法一：hash法构建新链表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    使用哈希表记录所有节点， key 为原节点，value 为克隆节点。<br>	遍历链表，完成记录，克隆节点暂时只记录对应的 val。<br>	再次遍历，完善克隆节点的 next 与 random。	<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        Map&lt;Node, Node&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next ) &#123;<br>            mp.put(p, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(p.val));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next ) &#123;<br>            mp.get(p).next = mp.get(p.next);<br>            mp.get(p).random = mp.get(p.random);<br>        &#125;<br>        <span class="hljs-keyword">return</span> mp.get(head);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 方法二：指针方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copy</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 复制原始值</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val);<br>            node.next = cur.next;<br>            cur.next = node;<br>            cur = cur.next.next;<br>        &#125;<br>        <span class="hljs-comment">// 复制随机指针</span><br>        cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            cur.next.random = cur.random == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : cur.random.next;<br>            cur = cur.next.next;<br>        &#125;<br>        <span class="hljs-comment">// 分裂成两个链表</span><br>        cur = head;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = tmp.next;<br>            tmp.next = tmp.next == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : tmp.next.next;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> copy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36 二叉搜索树与双向链表"></a>36 二叉搜索树与双向链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 双向链表：pre.right = cur、cur.left = pre、pre = cur</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public Node left;</span><br><span class="hljs-comment">    public Node right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val,Node _left,Node _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Node pre;<br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        dfs(root);<br>        head.left = pre;<br>        pre.right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node cur)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(cur.left);<br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">null</span>) &#123;<br>            head = cur;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre.right = cur;<br>        &#125;<br>        cur.left = pre;<br>        pre = cur;<br>        dfs(cur.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37 序列化二叉树"></a>37 序列化二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">你可以将以下二叉树：<br><br>    <span class="hljs-number">1</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>     / \<br>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>序列化为 <span class="hljs-string">&quot;[1,2,3,null,null,4,5]&quot;</span><br>    <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;[&quot;</span>);<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>                    str.append(node.val);<br>                    queue.offer(node.left);<br>                    queue.offer(node.right);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    str.append(<span class="hljs-string">&quot;null&quot;</span>);<br>                &#125;<br>                str.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str.deleteCharAt(str.length() - <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;]&quot;</span>).toString();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">null</span> || data == <span class="hljs-string">&quot;[]&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        String[] nodes = data.substring(<span class="hljs-number">1</span>, data.length() - <span class="hljs-number">1</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(nodes[<span class="hljs-number">0</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; idx &lt; nodes.length) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;null&quot;</span>.equals(nodes[idx])) &#123;<br>                    node.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(nodes[idx]));<br>                    queue.offer(node.left);<br>                &#125;<br>                idx++;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;null&quot;</span>.equals(nodes[idx])) &#123;<br>                    node.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(nodes[idx]));<br>                    queue.offer(node.right);<br>                &#125;<br>                idx++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38 字符串的排列"></a>38 字符串的排列</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输入一个字符串，打印出该字符串中字符的所有排列。</span><br><span class="hljs-comment">// 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入：s = &quot;abc&quot;</span><br><span class="hljs-comment">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> StringBuilder str;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; res;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> String[] permutation(String ss) &#123;<br>        <span class="hljs-comment">// 1、排序 2、去重 3、从0开始(不是组合，是排列)</span><br>        <span class="hljs-type">char</span>[] s = ss.toCharArray();<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length];<br>        str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 方式一: sort + used判断 去重</span><br>        <span class="hljs-comment">// Arrays.sort(s);</span><br>        <span class="hljs-comment">// backtracking(s, 0);</span><br>        <span class="hljs-comment">// 方式二: set 去重</span><br>        backtracking2(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[res.size()]);<br>    &#125;<br>    <span class="hljs-comment">// private void backtracking(char[] s, int idx) &#123;</span><br>    <span class="hljs-comment">//     if (idx == s.length) &#123;</span><br>    <span class="hljs-comment">//         res.add(str.toString());</span><br>    <span class="hljs-comment">//         return;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     for (int i = 0; i &lt; s.length; i ++ ) &#123;</span><br>    <span class="hljs-comment">//         if (used[i] == true || (i &gt; 0 &amp;&amp; s[i] == s[i - 1] &amp;&amp; used[i - 1] == false)) continue;</span><br>    <span class="hljs-comment">//         used[i] = true;</span><br>    <span class="hljs-comment">//         str.append(s[i]);</span><br>    <span class="hljs-comment">//         backtracking(s, idx + 1);</span><br>    <span class="hljs-comment">//         str.deleteCharAt(str.length() - 1);</span><br>    <span class="hljs-comment">//         used[i] = false;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking2</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> idx)</span> &#123;<br>        <span class="hljs-keyword">if</span> (idx == s.length) &#123;<br>            <span class="hljs-comment">// res.add(new String(s));</span><br>            res.add(String.valueOf(s));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> idx; i &lt; s.length; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(s[i])) <span class="hljs-keyword">continue</span>;<br>            set.add(s[i]);<br>            swap(s, idx, i);<br>            backtracking2(s, idx + <span class="hljs-number">1</span>);<br>            swap(s, idx, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s[i];<br>        s[i] = s[j];<br>        s[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39 数组中出现次数超过一半的数字"></a>39 数组中出现次数超过一半的数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 投票法</span><br>        <span class="hljs-comment">// int res = 0;</span><br>        <span class="hljs-comment">// int cnt = 0;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; nums.length; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     if (cnt == 0) &#123;</span><br>        <span class="hljs-comment">//         res = nums[i];</span><br>        <span class="hljs-comment">//         cnt++;</span><br>        <span class="hljs-comment">//     &#125; else &#123;</span><br>        <span class="hljs-comment">//         if (res == nums[i]) cnt++;</span><br>        <span class="hljs-comment">//         else cnt--;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return res;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>            mp.put(nums[i], mp.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (mp.getOrDefault(nums[i], <span class="hljs-number">0</span>) &gt; nums.length / <span class="hljs-number">2</span>) &#123;<br>                res = nums[i]; <br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40 最小的k个数"></a>40 最小的k个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 方式一： 优先队列，大顶堆</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (queue.size() &lt; k) &#123;<br>                queue.offer(arr[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (queue.peek() &gt; arr[i]) &#123;<br>                    queue.poll();<br>                    queue.offer(arr[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i ++ ) &#123;<br>            res[i] = queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 方式二：快速排序 + 二分（partition划分的是最终有序数组的下标i，左边是小于nums[i]的无序的数,右边是大于nums[i]的无序的数）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];        <br>        <span class="hljs-keyword">return</span> getKnum(arr, k, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] getKnum(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> partition(arr, l, r);<br>        <span class="hljs-keyword">if</span> (i == k - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Arrays.copyOf(arr, k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> i &gt; k - <span class="hljs-number">1</span> ? getKnum(arr, k, l, i - <span class="hljs-number">1</span>) : getKnum(arr, k, i + <span class="hljs-number">1</span>, r);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> arr[l];<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; x) r--;<br>            arr[l] = arr[r];<br>            <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt;= x) l++;<br>            arr[r] = arr[l]; <br>        &#125;<br>        arr[l] = x;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41 数据流中的中位数"></a>41 数据流中的中位数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//关键点： 中位数-&gt; 较小数的部分用大顶堆，较大数的部分用小顶堆,去中间数（两数的平均）</span><br>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">创建大根堆、小根堆，其中：大根堆存放较小的一半元素，小根堆存放较大的一半元素。</span><br><span class="hljs-comment">添加元素时，若两堆元素个数相等，放入小根堆（使得小根堆个数多 1）；若不等，放入大根堆（使得大小根堆元素个数相等）</span><br><span class="hljs-comment">取中位数时，若两堆元素个数相等，取两堆顶求平均值；若不等，取小根堆堆顶。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意： 大根堆多1也行，最后奇数返回大根堆的堆顶即可</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    PriorityQueue&lt;Integer&gt; maxHeap;<br>    PriorityQueue&lt;Integer&gt; minHeap;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br>        <span class="hljs-comment">// maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br>        maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>                <span class="hljs-comment">// return Integer.compare(b, a);</span><br>                <span class="hljs-keyword">return</span> b - a;<br>            &#125;<br>        &#125;);<br>        minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;<br>            maxHeap.offer(num);<br>            minHeap.offer(maxHeap.poll()); <span class="hljs-comment">// 小顶堆加1,大顶堆+1后-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            minHeap.offer(num);<br>            maxHeap.offer(minHeap.poll());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;<br>            <span class="hljs-keyword">return</span> (maxHeap.peek() + minHeap.peek()) / <span class="hljs-number">2.0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> minHeap.peek();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj.addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj.findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42 连续子数组的最大和"></a>42 连续子数组的最大和</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            f[i] = nums[i];<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] + f[i - <span class="hljs-number">1</span>] &gt; f[i]) &#123;<br>                f[i] = nums[i] + f[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            res = Math.max(res, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="43-1-n整数中1出现的次数"><a href="#43-1-n整数中1出现的次数" class="headerlink" title="43 1~n整数中1出现的次数"></a>43 1~n整数中1出现的次数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入一个整数 n ，求 1 ～ n 这 n 个整数的十进制表示中 1 出现的次数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">例如，输入 12，1 ～ 12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">789 hgih=7 low=89</span><br><span class="hljs-comment">700~789 f(low)</span><br><span class="hljs-comment">0~6 * 00~99  high * f(base - 1) 这里只统计low的1的个数</span><br><span class="hljs-comment">hgih=1  -&gt; 189  89+1    low + 1</span><br><span class="hljs-comment">high!=1 -&gt; 289  1 00~99  100 base</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(n);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, s.length() - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> n / base;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> n % base;<br>    <span class="hljs-keyword">if</span> (high == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> countDigitOne(low) + countDigitOne(base - <span class="hljs-number">1</span>) + low + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> countDigitOne(low) + high * countDigitOne(base - <span class="hljs-number">1</span>) + base;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44 数字序列中某一位的数字"></a>44 数字序列中某一位的数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 数字范围    数量  位数    占多少位</span><br><span class="hljs-comment">    1-9        9      1       9</span><br><span class="hljs-comment">    10-99      90     2       180</span><br><span class="hljs-comment">    100-999    900    3       2700</span><br><span class="hljs-comment">    1000-9999  9000   4       36000  ...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    例如 2901 = 9 + 180 + 2700 + 12 即一定是4位数,第12位   n = 12;</span><br><span class="hljs-comment">    数据为 = 1000 + (12 - 1)/ 4  = 1000 + 2 = 1002</span><br><span class="hljs-comment">    定位1002中的位置 = (n - 1) %  4 = 3    s.charAt(3) = 2;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNthDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// n所在的数的位数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 数据范围的第一个数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;  <span class="hljs-comment">// 占多少位</span><br>    <span class="hljs-keyword">while</span> (n &gt; cnt) &#123;<br>        n -= cnt;<br>        digit++;<br>        start *= <span class="hljs-number">10</span>;<br>        cnt = <span class="hljs-number">9</span> * digit * start;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> start + (n - <span class="hljs-number">1</span>) / digit;<br>    <span class="hljs-keyword">return</span> String.valueOf(num).charAt((<span class="hljs-type">int</span>)((n - <span class="hljs-number">1</span>) % digit)) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45 把数组排成最小的数"></a>45 把数组排成最小的数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        String[] strs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[nums.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>            strs[i] = String.valueOf(nums[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// Arrays.sort(strs, (a, b) -&gt; (a + b).compareTo(b + a)); // 3 _30 &gt; 30_3 所以30放在3前面</span><br>        <br>        <span class="hljs-comment">// Arrays.sort(strs, new Comparator&lt;String&gt;() &#123;</span><br>        <span class="hljs-comment">//     @Override</span><br>        <span class="hljs-comment">//     public int compare(String a, String b) &#123;</span><br>        <span class="hljs-comment">//         return (a + b).compareTo(b + a);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;);</span><br>        <br>        qsort(strs, <span class="hljs-number">0</span>, strs.length - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i ++ ) &#123;<br>            res.append(strs[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = r;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> strs[l + (r - l) / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> ((strs[i] + x).compareTo(x + strs[i]) &lt; <span class="hljs-number">0</span>) i++;<br>            <span class="hljs-keyword">while</span> ((strs[j] + x).compareTo(x + strs[j]) &gt; <span class="hljs-number">0</span>) j--;<br>            <span class="hljs-keyword">if</span> (i &lt;= j) &#123;<br>                swap(strs, i, j);<br>                i++;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l &lt; j) qsort(strs, l, j);<br>        <span class="hljs-keyword">if</span> (i &lt; r) qsort(strs, i, r);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> strs[i];<br>        strs[i] = strs[j];<br>        strs[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46 把数字翻译成字符串"></a>46 把数字翻译成字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">translateNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> num + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// String.valueOf(num);</span><br>    <span class="hljs-type">char</span>[] str = s.toCharArray();<br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[str.length + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 前i个字符翻译的方法数</span><br>    f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= str.length; i ++ ) &#123;<br>        f[i] = f[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (str[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1&#x27;</span> || (str[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; str[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-string">&#x27;6&#x27;</span>)) &#123;<br>            f[i] += f[i - <span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[str.length];<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47 礼物的最大价值"></a>47 礼物的最大价值</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ </span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-keyword">if</span> (grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i ++ ) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) f[i][j] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// f[i][j] = Math.max(f[i  - 1][j], f[i][j - 1]) + nums[i][j];</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) f[i][j] = Math.max(f[i][j], f[i - <span class="hljs-number">1</span>][j] + grid[i][j]);<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) f[i][j] = Math.max(f[i][j], f[i][j - <span class="hljs-number">1</span>] + grid[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48 最长不含重复字符的子字符串"></a>48 最长不含重复字符的子字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</span><br><span class="hljs-comment">// 经典滑动窗口问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">char</span>[] str = s.toCharArray();<br>    Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; str.length; r ++ ) &#123;<br>        <span class="hljs-keyword">while</span> (set.contains(str[r])) &#123;<br>            set.remove(str[l++]);<br>        &#125;<br>        set.add(str[r]);<br>        len = Math.max(len, r - l + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">char</span>[] str = s.toCharArray();<br>    Map&lt;Character, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; str.length; j ++ ) &#123;<br>        <span class="hljs-keyword">if</span> (mp.containsKey(str[j])) &#123;<br>            i = Math.max(i, mp.get(str[j]) + <span class="hljs-number">1</span>);<br>        &#125;<br>        mp.put(str[j], j);<br>        len = Math.max(len, j - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49 丑数"></a>49 丑数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</span><br><br>使用动态规划<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p3 = <span class="hljs-number">0</span>, p5 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i ++ ) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next2</span> <span class="hljs-operator">=</span> f[p2] * <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next3</span> <span class="hljs-operator">=</span> f[p3] * <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next5</span> <span class="hljs-operator">=</span> f[p5] * <span class="hljs-number">5</span>;<br>        f[i] = Math.min(Math.min(next2, next3), next5);<br>        <span class="hljs-keyword">if</span> (f[i] == next2) p2++;<br>        <span class="hljs-keyword">if</span> (f[i] == next3) p3++;<br>        <span class="hljs-keyword">if</span> (f[i] == next5) p5++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50 第一个只出现一次的字符"></a>50 第一个只出现一次的字符</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>     <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>     <span class="hljs-keyword">if</span> (chars.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>     <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i ++ ) &#123;<br>         st[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>     &#125;<br><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i ++ ) &#123;<br>         <span class="hljs-keyword">if</span> (st[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) &#123;<br>             <span class="hljs-keyword">return</span> chars[i];<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br> &#125;<br></code></pre></td></tr></table></figure>

<h2 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51 数组中的逆序对"></a>51 数组中的逆序对</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br><br>输入: [<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出: <span class="hljs-number">5</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">50050</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> mergeSort(nums, l, mid);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mergeSort(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> left + right;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>                tmp[idx++] = nums[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res += mid - i + <span class="hljs-number">1</span>;<br>                tmp[idx++] = nums[j++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            tmp[idx++] = nums[i++];<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (j &lt;= r) &#123;<br>            tmp[idx++] = nums[j++];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; idx; k++ ) &#123;<br>            nums[l + k] = tmp[k];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;    <br>    <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 方法: 归并排序，合并的时候，左边大于右边的数就开始统计cnt</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cnt;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">51000</span>];<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cnt = <span class="hljs-number">0</span>;<br>        mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        mergeSort(nums, l, mid);  <span class="hljs-comment">// 注意左右数组都有序</span><br>        mergeSort(nums, mid + <span class="hljs-number">1</span>, r);<br>        merge(nums, l, mid, r);<br>    &#125;<br>	<span class="hljs-comment">// 方法一</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-comment">// int[] tmp = new int[r - l + 1];</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>                tmp[idx++] = nums[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cnt += mid - i + <span class="hljs-number">1</span>;   <span class="hljs-comment">//  1 2 6 8 9    3 4 7    对于6 &gt; 3 产生【6, 3】【8, 3】【9, 3】逆序对     </span><br>                tmp[idx++] = nums[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[idx++] = nums[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= r) tmp[idx++] = nums[j++];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; idx; k ++ ) &#123;<br>            nums[l + k] = tmp[k];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 方法二</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-comment">// int[] tmp = new int[r - l + 1];</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>                tmp[idx++] = nums[i++];<br>                cnt += j - (mid + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;   <br>                tmp[idx++] = nums[j++];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            tmp[idx++] = nums[i++]; <br>            cnt += j - (mid + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt;= r) tmp[idx++] = nums[j++];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; idx; k ++ ) &#123;<br>            nums[l + k] = tmp[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52 两个链表的第一个公共节点"></a>52 两个链表的第一个公共节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输入两个链表，找出它们的第一个公共节点。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curA</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curB</span> <span class="hljs-operator">=</span> headB;<br>        <br>        <span class="hljs-keyword">while</span> (curA != curB) &#123;<br>            curA = curA != <span class="hljs-literal">null</span> ? curA.next : headB;<br>            curB = curB != <span class="hljs-literal">null</span> ? curB.next : headA;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> curA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="53-i-在排序数组中查找数字I"><a href="#53-i-在排序数组中查找数字I" class="headerlink" title="53-i 在排序数组中查找数字I"></a>53-i 在排序数组中查找数字I</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 统计一个数字在排序数组中出现的次数。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[l] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> l;<br>    l = <span class="hljs-number">0</span>;<br>    r = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) r = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r - tmp + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="53-ii-0-n-1中缺失的数字"><a href="#53-ii-0-n-1中缺失的数字" class="headerlink" title="53-ii 0~n-1中缺失的数字"></a>53-ii 0~n-1中缺失的数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>        res ^= i ^ nums[i];<br>    &#125;<br>    res ^= n;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54 二叉搜索树的第k大节点"></a>54 二叉搜索树的第k大节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 给定一棵二叉搜索树，请找出其中第 k 大的节点。</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> res;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cur;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>       cur = k;<br>       res = <span class="hljs-number">0</span>;<br>       inorder(root);<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>       inorder(root.right);<br>       cur--;<br>       <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) &#123;<br>           res = root.val;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       inorder(root.left);<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="55-i-二叉树的深度"><a href="#55-i-二叉树的深度" class="headerlink" title="55-i 二叉树的深度"></a>55-i 二叉树的深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       	<span class="hljs-comment">// 方式一： 深搜</span><br>        <span class="hljs-comment">// return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;</span><br>		<br>        <span class="hljs-comment">// 方式二: 层次遍历</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            depth++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="55-ii-平衡二叉树"><a href="#55-ii-平衡二叉树" class="headerlink" title="55-ii 平衡二叉树"></a>55-ii 平衡二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过 1，那么它就是一棵平衡二叉树。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right) &amp;&amp; <br>        Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="hljs-number">1</span>;<br>&#125;   <br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">depth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="56-i-数组中数字出现的次数"><a href="#56-i-数组中数字出现的次数" class="headerlink" title="56-i 数组中数字出现的次数"></a>56-i 数组中数字出现的次数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumbers(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        res ^= num;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((diff &amp; res) == <span class="hljs-number">0</span>) &#123;<br>        diff &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> ((num &amp; diff) == <span class="hljs-number">0</span>) a ^= num;<br>        <span class="hljs-keyword">else</span> b ^= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a, b&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="56-ii-数组中数字出现的次数-ii"><a href="#56-ii-数组中数字出现的次数-ii" class="headerlink" title="56-ii 数组中数字出现的次数 ii"></a>56-ii 数组中数字出现的次数 ii</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// Map&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;();</span><br>    <span class="hljs-comment">// for (int i = 0; i &lt; nums.length; i ++ ) &#123;</span><br>    <span class="hljs-comment">//     mp.put(nums[i], mp.getOrDefault(nums[i], 0) + 1);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// for (Map.Entry&lt;Integer, Integer&gt; enrty : mp.entrySet()) &#123;</span><br>    <span class="hljs-comment">//     if (enrty.getValue() == 1) return enrty.getKey();</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// return -1;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        0 ^ x = x</span><br><span class="hljs-comment">        x ^ x = 0</span><br><span class="hljs-comment">        x &amp; ~x = 0</span><br><span class="hljs-comment">        x &amp; ~0 =x</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: nums) &#123;<br>        a = (a ^ num) &amp; ~b;<br>        b = (b ^ num) &amp; ~a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="57-i-和为s的两个数字"><a href="#57-i-和为s的两个数字" class="headerlink" title="57-i  和为s的两个数字"></a>57-i  和为s的两个数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// hash</span><br>        <span class="hljs-comment">// Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; nums.length; i++ ) &#123;</span><br>        <span class="hljs-comment">//     if (set.contains(target - nums[i])) &#123;</span><br>        <span class="hljs-comment">//         return new int[] &#123;nums[i], target - nums[i]&#125;;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//     set.add(nums[i]);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return null;</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[l] + nums[r];<br>            <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[l], nums[r]&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                l++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="57-ii-和为s的连续正数序列"><a href="#57-ii-和为s的连续正数序列" class="headerlink" title="57-ii 和为s的连续正数序列"></a>57-ii 和为s的连续正数序列</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。<br>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 滑动窗口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] findContinuousSequence(<span class="hljs-type">int</span> target) &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; r &lt; target; r++ ) &#123;<br>            sum += r;<br>            <span class="hljs-keyword">while</span> (sum &gt; target) &#123;<br>                sum -= l;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r - l + <span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// for (int i = 0; i &lt; tmp.length; i++ ) &#123;</span><br>                <span class="hljs-comment">//     tmp[i] = l + i;</span><br>                <span class="hljs-comment">// &#125;</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i++ ) &#123;<br>                    tmp[idx++] = i;<br>                &#125;<br>                res.add(tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;    <br>    <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] findContinuousSequence(<span class="hljs-type">int</span> target) &#123;<br>    List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (l + r) * (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            r++;	<span class="hljs-comment">// 不够大，往右扩大</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            l++;  <span class="hljs-comment">// 以l为边界不存在合理的和</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r - l + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i ++ ) &#123;<br>                res[i - l] = i;<br>            &#125;<br>            list.add(res);<br>            l++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="58-i-翻转单词顺序"><a href="#58-i-翻转单词顺序" class="headerlink" title="58-i 翻转单词顺序"></a>58-i 翻转单词顺序</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: &quot;  hello world!  &quot;</span><br><span class="hljs-comment">输出: &quot;world! hello&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>    String[] strs = s.split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;&quot;</span>.equals(strs[i])) &#123;<br>            str.append(strs[i]).append(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (str.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">return</span> str.deleteCharAt(str.length() - <span class="hljs-number">1</span>).toString(); <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="58-ii-左旋转字符串"><a href="#58-ii-左旋转字符串" class="headerlink" title="58-ii 左旋转字符串"></a>58-ii 左旋转字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字 2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 方式一：直接字符拼接</span><br>        <span class="hljs-comment">// return s.substring(k, s.length()) + s.substring(0, k);</span><br><br>        <span class="hljs-comment">// 方式二：</span><br>        <span class="hljs-comment">// char[] chars = s.toCharArray();</span><br>        <span class="hljs-comment">// StringBuilder str = new StringBuilder();</span><br>        <span class="hljs-comment">// for (int i = k; i &lt; k + chars.length; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     str.append(chars[i % chars.length]);</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-comment">// return str.toString();</span><br><br>        <span class="hljs-comment">// 方式三</span><br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <br>        reverse(chars, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        reverse(chars, k, chars.length - <span class="hljs-number">1</span>);<br>        reverse(chars, <span class="hljs-number">0</span>, chars.length - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> String.valueOf(chars);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-comment">// for (int i = 0; i &lt; (r - l + 1) / 2; i ++ ) &#123;</span><br>        <span class="hljs-comment">//     char t = chars[l + i];</span><br>        <span class="hljs-comment">//     chars[l + i] = chars[r - i];</span><br>        <span class="hljs-comment">//     chars[r - i] = t;</span><br>        <span class="hljs-comment">// &#125; </span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = r; i &lt; j; i++, j-- ) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> chars[i];<br>            chars[i] = chars[j];<br>            chars[j] = t;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<h2 id="59-i-滑动窗口的最大值"><a href="#59-i-滑动窗口的最大值" class="headerlink" title="59-i 滑动窗口的最大值"></a>59-i 滑动窗口的最大值</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">单调队列</span><br><span class="hljs-comment">q = deque()</span><br><span class="hljs-comment">for i in range(n):</span><br><span class="hljs-comment">    # 判断队头是否滑出窗口</span><br><span class="hljs-comment">    while q and checkout_out(q[0]):</span><br><span class="hljs-comment">        q.popleft()</span><br><span class="hljs-comment">    while q and check(q[-1]):</span><br><span class="hljs-comment">        q.pop()</span><br><span class="hljs-comment">    q.append(i)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br><br>    Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; i - queue.peekFirst() + <span class="hljs-number">1</span> &gt; k) &#123;<br>            queue.pollFirst();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()]) &#123;<br>            queue.pollLast();<br>        &#125;<br>        queue.offer(i);<br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>            res[idx++] = nums[queue.peekFirst()];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="59-ii-队列的最大值"><a href="#59-ii-队列的最大值" class="headerlink" title="59-ii 队列的最大值"></a>59-ii 队列的最大值</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(<span class="hljs-number">1</span>)。<br><br>若队列为空，pop_front 和 max_value 需要返回 -<span class="hljs-number">1</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; dataQueue;<br>    <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; maxQueue;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxQueue</span><span class="hljs-params">()</span> &#123;<br>        dataQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        maxQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max_value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> maxQueue.isEmpty() ? -<span class="hljs-number">1</span> : maxQueue.peekFirst();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!maxQueue.isEmpty() &amp;&amp; maxQueue.peekLast() &lt; value) &#123;<br>            maxQueue.pollLast();<br>        &#125;<br>        dataQueue.offer(value);<br>        maxQueue.offer(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop_front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (dataQueue.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dataQueue.pollFirst(); <span class="hljs-comment">// data必须弹出</span><br>        <span class="hljs-keyword">if</span> (res == maxQueue.peekFirst()) maxQueue.pollFirst(); <br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MaxQueue obj = new MaxQueue();</span><br><span class="hljs-comment"> * int param_1 = obj.max_value();</span><br><span class="hljs-comment"> * obj.push_back(value);</span><br><span class="hljs-comment"> * int param_3 = obj.pop_front();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h2 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60 n个骰子的点数"></a>60 n个骰子的点数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</span><br><span class="hljs-comment">//你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] dicesProbability(<span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">6</span> * n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j ++ ) &#123;<br>        f[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i ++ ) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= <span class="hljs-number">6</span> * i; j ++ ) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">6</span> &amp;&amp; j &gt; k; k ++ ) &#123;<br>                f[i][j] += f[i - <span class="hljs-number">1</span>][j - k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">5</span> * n + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">double</span> <span class="hljs-variable">all</span> <span class="hljs-operator">=</span> Math.pow(<span class="hljs-number">6</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> * n + <span class="hljs-number">1</span>; i ++ ) &#123;<br>        res[i] = f[n][n + i] * <span class="hljs-number">1.0</span> / all;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61 扑克牌中的顺子"></a>61 扑克牌中的顺子</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStraight</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    Arrays.sort(nums);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">joker</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++ ) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>            joker++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt;= <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-type">int</span> <span class="hljs-variable">minValue</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><br><span class="hljs-type">boolean</span>[] t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">14</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-keyword">if</span> (t[nums[i]] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    t[nums[i]] = <span class="hljs-literal">true</span>;<br><br>    maxValue = Math.max(maxValue, nums[i]);<br>    minValue = Math.min(minValue, nums[i]);<br>&#125;<br><span class="hljs-keyword">return</span> maxValue - minValue &lt;= <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure>

<h2 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62 圆圈中最后剩下的数字"></a>62 圆圈中最后剩下的数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0,1,,n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。</span><br><br><span class="hljs-comment">//例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-comment">// Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();</span><br>    <span class="hljs-comment">// for (int i = 0; i &lt; n; i ++ ) &#123;</span><br>    <span class="hljs-comment">//     q.offer(i);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// int res = -1;</span><br>    <span class="hljs-comment">// while (q.size() &gt; 1) &#123;</span><br>    <span class="hljs-comment">//     for (int i = 0; i &lt; m - 1; i ++ ) &#123;</span><br>    <span class="hljs-comment">//         q.offer(q.poll());</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     q.poll();</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// return q.poll();</span><br><br>    <span class="hljs-comment">// // 方法二：</span><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>        list.add(i);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (list.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        idx = (idx + m - <span class="hljs-number">1</span>) % list.size();<br>        list.remove(idx);<br>    &#125;<br>    <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// // 方法三：</span><br>    <span class="hljs-comment">// // int res = 0;</span><br>    <span class="hljs-comment">// // for (int i = 2; i &lt;= n; i ++ ) &#123;</span><br>    <span class="hljs-comment">// //     res = (res + m) % i;</span><br>    <span class="hljs-comment">// // &#125;</span><br><br>    <span class="hljs-comment">// // return res;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63 股票的最大利润"></a>63 股票的最大利润</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-keyword">if</span> (prices == <span class="hljs-literal">null</span> | prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 注意是买卖一次</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i ++ ) &#123;<br>            min = Math.min(min, prices[i]);<br>            res = Math.max(res, prices[i] - min);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="64-求1-2-…-n"><a href="#64-求1-2-…-n" class="headerlink" title="64 求1+2+…+n"></a>64 求1+2+…+n</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 求1+2+…+n</span><br><span class="hljs-comment">// 要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n += sumNums(n - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 不用加减乘除做加法</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。<br><span class="hljs-comment">// 迭代方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-comment">// (a ^ b) ^ ((a &amp; b) &lt;&lt; 1)</span><br>    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a ^ b;<br>        b = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>        a = sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>    <br>    <span class="hljs-comment">// 递归方法</span><br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> add((a ^ b), ((a &amp; b) &lt;&lt; <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66 构建乘积数组"></a>66 构建乘积数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">给定一个数组 A[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,…,n-<span class="hljs-number">1</span>]，请构建一个数组 B[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,…,n-<span class="hljs-number">1</span>]，其中 B 中的元素 B[i]=A[<span class="hljs-number">0</span>]×A[<span class="hljs-number">1</span>]×…×A[i-<span class="hljs-number">1</span>]×A[i+<span class="hljs-number">1</span>]×…×A[n-<span class="hljs-number">1</span>]。不能使用除法。<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] constructArr(<span class="hljs-type">int</span>[] a) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, left = <span class="hljs-number">1</span>; i &lt; n; i ++ ) &#123;<br>        res[i] = left;<br>        left *= a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) &#123;<br>        res[i] *= right;<br>        right *= a[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67 把字符串转换成整数"></a>67 把字符串转换成整数</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。<br>假设我们的环境只能存储 <span class="hljs-number">32</span> 位大小的有符号整数，那么其数值范围为 [−<span class="hljs-number">231</span>,  <span class="hljs-number">231</span> − <span class="hljs-number">1</span>]。如果数值超过这个范围，请返回  INT_MAX (<span class="hljs-number">231</span> − <span class="hljs-number">1</span>) 或 INT_MIN (−<span class="hljs-number">231</span>) 。<br>在任何情况下，若函数不能进行有效的转换时，请返回 <span class="hljs-number">0</span>。<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strToInt</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || str.trim().length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span>[] s = str.toCharArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; s.length &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>        sign = -<span class="hljs-number">1</span>;<br>        i++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">hasNum</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; s.length; i ++ ) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> ((num &lt; <span class="hljs-number">0</span> || num &gt; <span class="hljs-number">9</span>) &amp;&amp; hasNum == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> ((num &lt; <span class="hljs-number">0</span> || num &gt; <span class="hljs-number">9</span>) &amp;&amp; hasNum == <span class="hljs-literal">true</span>) <span class="hljs-keyword">break</span>;<br>        hasNum = <span class="hljs-literal">true</span>; <br>        <span class="hljs-keyword">if</span> (res &gt; (Integer.MAX_VALUE - num) / <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;<br>        &#125;<br>        res = res * <span class="hljs-number">10</span> + num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sign * res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="68-i-二叉搜索树的最近公共祖先"><a href="#68-i-二叉搜索树的最近公共祖先" class="headerlink" title="68-i 二叉搜索树的最近公共祖先"></a>68-i 二叉搜索树的最近公共祖先</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="hljs-comment">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="hljs-comment">例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == q) <span class="hljs-keyword">return</span> p;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br>        <span class="hljs-comment">//     return lowestCommonAncestor(root.right, p, q);</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-comment">// if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br>        <span class="hljs-comment">//     return lowestCommonAncestor(root.left, p, q);</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-comment">// return root;</span><br><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;<br>                root = root.right;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;<br>                root = root.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="68-ii-二叉树的最近公共祖先"><a href="#68-ii-二叉树的最近公共祖先" class="headerlink" title="68-ii 二叉树的最近公共祖先"></a>68-ii 二叉树的最近公共祖先</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br><br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br><br>例如，给定如下二叉树:  root = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">null</span> &amp;&amp; left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>刷题相关</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>搜索</tag>
        <tag>查找</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>排序</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
</search>
